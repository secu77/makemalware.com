[{"content":"","date":"1 marzo 2023","permalink":"/es/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 marzo 2023","permalink":"/es/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 marzo 2023","permalink":"/es/tags/ctf/","section":"Tags","summary":"","title":"ctf"},{"content":"","date":"1 marzo 2023","permalink":"/es/categories/defense-evasion/","section":"Categories","summary":"","title":"Defense Evasion"},{"content":"","date":"1 marzo 2023","permalink":"/es/tags/kraken/","section":"Tags","summary":"","title":"kraken"},{"content":"","date":"1 marzo 2023","permalink":"/es/","section":"MakeMalware","summary":"","title":"MakeMalware"},{"content":"","date":"1 marzo 2023","permalink":"/es/tags/redteam/","section":"Tags","summary":"","title":"redteam"},{"content":"","date":"1 marzo 2023","permalink":"/es/authors/secu/","section":"Authors","summary":"","title":"secu"},{"content":"\rPresentación # Squid Game es un CTF creado para el congreso Hc0n 2023. La ambientación se ha basado en la serie de Netflix: El Juego del Calamar.\nLas características de este CTF son las siguientes:\nSe trata de tres retos estilo Boot2Root (conseguir los máximos privilegios). Se utiliza el servicio web como vía de Acceso Inicial. Las tres máquinas han sido configuradas para evitar la ejecución de comandos y no disponen de salida a Internet. El objetivo es realizar una post-explotación a través de la webshell y conseguir escalar privilegios. No será necesario realizar ningúna explotación web adiccional, ya que los retos estan centrados en la post-explotación y por eso se facilita el acceso inicial. Las elevaciones de privilegios son bastante sencillas, no obstante, la dificultad reside en las condiciones que dificultan la explotación. A continuación se mostrará la solución propuesta para cada uno de los retos utilizando Kraken, la herramienta que he desarrollado y he presentado en la Hc0n 2023.\nkraken-ng/Kraken\rKraken, a modular multi-language webshell coded by @secu_x11\rPython 392\r37\rDicho esto\u0026hellip; ¡Comencemos!\nReto 1 - Red Light, Green Light # Nombre: \u0026ldquo;Red Light, Green Light\u0026rdquo; Sistema Operativo: Linux Tecnología Web: Apache + PHP URL: https://challenge-01.makemalware.com Al visitar el enlace del primer reto nos encontramos con la siguiente web:\nEn el robots.txt de la página podemos descubrir un endpoint no indexado: /upload.php\nDespliegue de Webshell PHP # Al visitar este endpoint, encontramos lo que parece ser una subida arbitraria de archivos:\nPara confirmar la vulnerabilidad, se puede subir un agente de Kraken del tipo Standard y en lenguaje PHP.\nkraken-ng/agents\rAgents for https://github.com/kraken-ng/Kraken\rPHP 6\r0\rTras subirlo, la página nos devuelve la ruta remota donde se ha subido el archivo. Tras validar que este es accesible, se procede a generar un perfil de conexión para conectarnos al agente de Kraken.\nPuedes generar perfiles de conexión a medida por medio de una utilidad que Kraken ofrece. Esta se llama req2profile y permite transformar peticiones de Burpsuite a Perfiles de Conexión compatibles con Kraken.\rTras definir los campos del JSON como se ve anteriormente, podemos conectarnos al agente:\nReconocimiento del equipo # Con el implante desplegado, y el cliente conectado, podemos comenzar con el reconocimiento local del equipo.\nEn primer lugar, se puede comprobar que no es posible ejecutar comandos del sistema a través de la propia webshell:\nEsto se debe a que las funciones típicas de PHP para ejecutar comandos han sido deshabilitadas mediante la configuración de PHP (disabled_functions).\nEs posible obtener el listado de las funciones deshabilitadas a través de Kraken utilizando el módulo webinfo\nNo obstante, esta configuración no nos impide movernos por el sistema de archivos utilizando funcionalidades nativas que el propio PHP nos aporta.\nSi nos fijamos en el directorio /opt, podemos encontrar una carpeta squid-control junto con varios archivos y directorios de interés.\nAnalizando el contenido de los archivos y la información de contexto podemos identificar una vulnerabilidad del tipo Wildcard Poisoning1 en el script /opt/squid-control/green-light.sh\nExplotación de Wildcard Poisoning # El Wildcard Poisoning se produce debido a que, el script, esta utilizando un \u0026ldquo;wildcard\u0026rdquo; (*) como argumento del comando tar (indicando que se deben comprimir todos los archivos del directorio /var/www/html/files).\nEste comando presenta una vulnerabilidad ya que, el wildcard permite que el nombre de un archivo sea tomado como un argumento del propio comando tar.\rY precisamente, el comando tar contiene una serie de argumentos que pueden desembocar en una ejecución de código arbitrario2.\nNo obstante, para confirmar la elevación de privilegios, podemos observar la carpeta /opt/squid-control/tmp donde podemos ver como, cada minuto, se crea un archivo con el formato: \u0026lt;fecha\u0026gt;.tar.gz que contiene los archivos del directorio /var/www/html/files.\nAdemás, el propietario de estos archivos es el usuario root. Por tanto, se puede pensar que es posible que exista un cronjob que este ejecutando el script /opt/squid-control/green-light.sh cada minuto.\nPara confirmar esta teoría, se puede utilizar el módulo de Kraken pspy\nEste módulo lista los procesos de Linux a partir de la información contenida bajo el sistema de archivos: /proc. Al listar esta ruta, podemos descubrir una serie de subdirectorios con valores numéricos. Estos se corresponden con los PID existentes en la máquina, y se tratan de archivos virtuales que contienen la información de cada proceso.\rPuedes encontrar más información acerca de este sistema de archivos aquí.3\nEl módulo obtiene el listado de procesos en cada intervalo (-i), durante los segundos indicados (-d). En este período detecta aquellos procesos que se inician, así como los que se detienen, y los muestra en un formato intuitivo:\nDe esta forma podemos confirmar la ejecución del script /opt/squid-control/green-light.sh a través de un cronjob ejecutado como root (de otra forma no hubiera sido posible ya que no se pueden listar los cronjobs de otros usuarios sin privilegios).\nAntes de proceder con la explotación, se listan los puertos en uso en la máquina víctima. Para esto podemos apoyarnos en el módulo netstat que obtiene la información de red a partir de los archivos virtuales bajo /proc/net/\nGracias a este módulo podemos identificar la existencia de un posible servicio SSH escuchando en la dirección 127.0.0.1:22.\nCon la información recopilada podemos plantear el siguiente vector de elevación de privilegios:\nSe sube un script a la máquina que, cuando se ejecute, añada una clave pública SSH al archivo /root/.ssh/authorized_keys. Esto permitirá realizar una autenticación basada en clave pública4 como el usuario root. #!/bin/bash mkdir -p /root/.ssh/ echo -n \u0026#34;ssh-rsa AAAAB3...JMClw==\u0026#34; \u0026gt; /root/.ssh/authorized_keys Después, creamos los archivos que producen la explotación del Wildcard poisoning y ejecutan el script del paso anterior. Acceso SSH vía HTTP Tunneling # Pasados unos segundos, procederemos a subir una utilidad de tunelización que nos permitirá comunicarnos con los servicios internos de la máquina. Para este caso, yo utilizaré la herramienta pivotnacci.\nblackarrowsec/pivotnacci\rA tool to make socks connections through HTTP agents\rPython 602\r110\rSubo el agente PHP al directorio /var/www/html/files utilizando el módulo upload de Kraken.\nEste módulo permite subir archivos locales en chunks, especificando el delay entre peticiones (-d) así como el tamaño de cada chunk (-c). Y, en caso de interrumpirse/cortarse la transferencia, se puede reanudar especificando el último seek transmitido (-s). Esta es una buena opción a la hora de subir archivos pesados.\rCon la utilidad de tunelización desplegada, podemos usar la clave privada SSH para autenticarnos contra el servicio local de la máquina víctima y conseguir así una consola como root.\nFinalmente, a través de esta consola, disponemos de todos los privilegios y podemos obtener la flag del reto.\nAntes de finalizar borramos los archivos que hemos utilizado en la elevación de privilegios.\nLD_PRELOAD y flag alternativa # No obstante, el reto no concluye aquí. Se presenta la posibilidad de introducir una flag \u0026ldquo;alternativa\u0026rdquo; que se escapa de la vía principal del reto.\nEn caso de haber intentado evadir la configuración relacionada con las disabled_functions, es posible que se haya intentado hacer mediante alguna herramienta como Chankro la cual es bien conocida en este tipo de post explotaciones.\nTarlogicSecurity/Chankro\rHerramienta para evadir disable_functions y open_basedir\rPython 346\r77\rNo obstante, en las funciones deshabilitadas se encuentran aquellas que nos permiten realizar la evasión con esta herramienta. Aunque, si observamos las variables del sistema definidas para nuestro usuario www-data podemos descubrir un valor predefinido en la variable LD_PRELOAD\nEsta variable apunta a una libreria situada en /usr/local/lib/falcon.so. Utilizando el módulo download de Kraken podemos descargarla.\nEn este punto, podríamos realizar ingeniería inversa y analizar el funcionamiento de la misma, aunque es posible recuperar la flag alternativa de los strings de la sección de datos de la libreria.\nA pesar de haber obtenido la flag, voy a explicar el funcionamiento y el propósito que tiene esta librería:\nEn primer lugar, se trata de una adaptación del código de zap-args de TheHackersChoice.\nhackerschoice/thc-tips-tricks-hacks-cheat-sheet\rVarious tips \u0026amp; tricks\rC 2257\r294\rEl código zap-args.c es una utilidad enfocada a la evasión de defensas, que se centra en esconder los argumentos pasados a un comando o binario. Lo que hace es utilizar la variable LD_PRELOAD para interceptar la llamada al main de la ejecución de tu comando y vacía la referencía a la matriz de argumentos que se le pasa. De esta forma, al hacer un ps, el kernel no es capaz de recuperar los argumentos pasados al programa, ya que la referencia esta vacía, y simplemente muestra el binario en cuestión.\nEn mi caso, yo he utilizado la misma idea pero no para \u0026ldquo;ocultar\u0026rdquo; los argumentos, sino para interceptarlos como lo haría un EDR. De esta forma se pueden interceptar aquellos comandos ejecutados por el usuario www-data y, en caso de llamar a una shell, bloquearlos.\nEl código de falcon.so es el siguiente:\n/* * gcc -Wall -O2 -fpic -shared -o hook.so hook.c -ldl */ #define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;pwd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; typedef int (*pfi)(int, char **, char **); static pfi real_main; int check_args(int argc, char** argv) { if (argc \u0026lt; 1) return 0; // Checking for shell execution if (strcmp(argv[0], \u0026#34;sh\u0026#34;) == 0) return 1; else if (strcmp(argv[0], \u0026#34;bash\u0026#34;) == 0) return 1; else if (strcmp(argv[0], \u0026#34;rbash\u0026#34;) == 0) return 1; else if (strcmp(argv[0], \u0026#34;dash\u0026#34;) == 0) return 1; return 0; } static int mymain(int argc, char** argv, char** env) { struct passwd *p = getpwuid(getuid()); if (strcmp(p-\u0026gt;pw_name, \u0026#34;www-data\u0026#34;) == 0) { if (check_args(argc, argv) == 1) { char *alt_flag = \u0026#34;squid-game{Byp4ssAllTh3Th1ngS!}\u0026#34;; printf(\u0026#34;Nice try! But it\u0026#39;s not this way. Although, here is your alternative fl4g: %s\u0026#34;, alt_flag); exit(0); } } return real_main(argc, argv, env); } int __libc_start_main(pfi main, int argc, char **ubp_av, void (*init) (void), void (*fini)(void), void (*rtld_fini)(void), void (*stack_end)) { static int (*real___libc_start_main)() = NULL; if (!real___libc_start_main) { char *error; real___libc_start_main = dlsym(RTLD_NEXT, \u0026#34;__libc_start_main\u0026#34;); if ((error = dlerror()) != NULL) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, error); exit(1); } } real_main = main; return real___libc_start_main(mymain, argc, ubp_av, init, fini, rtld_fini, stack_end); } Obviamente, es un insulto esperar que esto sirva como \u0026ldquo;bloqueo\u0026rdquo; ante alguien que ha evadido las defensas propuestas. No obstante, es una mera recompensa de cara a mostrar al jugador que, lo ha hecho bien, pero que no es el camino.\nY hasta aquí llega el primer reto.\nReto 2 - Dalgona Candy # Nombre: \u0026ldquo;Dalgona Candy\u0026rdquo; Sistema Operativo: Windows Tecnología Web: IIS + ASPX URL: https://challenge-02.makemalware.com Accediendo a la url del reto podemos encontrarnos la siguiente vista:\nInspeccionando el código de la página descubrimos una ruta /upload.aspx oculta:\nDespliegue de Webshell ASPX # Al visitarla podemos ver, de igual forma que en el primer reto, una subida arbitraria de archivos.\nEn este caso, procedemos a subir un un agente de Kraken como ASPX\nGeneramos el perfil de conexión especificando la ruta del nuevo agente desplegado:\nY finalmente nos conectamos a la webshell utilizando Kraken.\nReconocimiento local # En primer lugar, se comprueba que hay un App Locker instalado en la máquina que nos impide ejecutar comandos con el Application Pool Identity actual (WINWS02\\webusr).\nEn este punto, podríamos comenzar a hacer un reconocimiento exhaustivo en busca de servicios vulnerables, programas en uso, archivos con credenciales, etc. Pero en este caso, la explotación será mucho más sencilla.\nPrimero comprobamos el contexto de nuestro usuario, así como sus privilegios. Utilizando el módulo whoami resulta bastante fácil.\nComo se puede observar, se dispone del privilegio SeImpersonate, del cual podemos abusar para conseguir elevar a SYSTEM.\nElevación de Privilegios con SeImpersonate Privilege # Para hacer esto, voy a utilizar una versión modificada del programa BadPotato.\nBadPotato utiliza el servicio de impresión de Windows (spoolss) para explotar una Autenticación Forzada5. Esta autenticación forzada se produce a través de la llamada RPC: RpcRemoteFindFirstPrinterChangeNotificationEx(), que genera un objeto de notificación que monitoriza los cambios de un objeto de impresión. Esto se utiliza para forzar a que el servicio de impresión se conecte a una NamedPipe que nosotros hemos creado y robarle el token de acceso. Como el usuario que corre el servicio de impresión es la cuenta del sistema, podremos utilizar su token para elevar priviegios.\nBeichenDream/BadPotato\rWindows 权限提升 BadPotato\rC# 658\r131\rEn la modificación elimino toda la parte de la creación del proceso que utiliza BadPotato para ejecutar como SYSTEM.\nPor otro lado, al eliminar el CloseHandle() de la referencia el token duplicado, propicio a su filtración (leak). De esta forma, el token queda filtrado en mi propio proceso (w3wp.exe) y puedo utilizarlo posteriormente desde el propio contexto de la webshell.\nDe esta forma, además de conseguir elevar privilegios, mantengo el contexto privilegiado a partir de la referencia al token. Lo que podría considerarse como una Elevación de Privilegios + Persistencia.\rA través del módulo execute_assembly de Kraken, puedo cargar el NET Assembly de la versión modificada de BadPotato y conseguir el leak del token de SYSTEM.\nCon el módulo set_token puedo utilizar la referencia del token para hacer efectiva la suplantación de la cuenta del sistema. Utilizando un token de impersonación derivado del filtrado, puedo conseguir que, todos los modulos que Kraken ejecute, lo hagan bajo el contexto de seguridad de SYSTEM:\nTras esto, se ha conseguido elevar privilegios y se dispone de una \u0026ldquo;pseudo-consola\u0026rdquo; como el usuario SYSTEM. Asi que, es posible leer la flag del escritorio del Administrador local de la máquina y completando el reto.\nExtracción de la SAM, SECURITY y SYSTEM del registro # No obstante, en un escenario más realista, no bastaría con demostrar que se disponen de privilegios. Sería necesario realizar algún tipo de post explotación para comprometer la máquina y/o obtener credenciales.\nPara demostrar la posibilidad de realizar esta tarea con Kraken, se utilizará el módulo secretsdump que nos permitirá extraer la SAM, SECURITY y SYSTEM del registro de la máquina.\nEl módulo secretsdump combina la impersonación con el uso de los Transacted Files para conseguir que, la llamada a NtSaveKey() guarde el contenido de la clave del registro en un archivo \u0026ldquo;en memoria\u0026rdquo;. De esta forma podemos acceder a su contenido, pero este no llega a escribirse en disco, por tanto podemos exfiltrarlo y sin necesidad de llegar a completar la transacción.\rEn el momento en el que el módulo escribe los archivos a nuestro equipo local, podemos usar la utilidad: secretsdump de Impacket para obtener las cuentas locales de la máquina.\nfortra/impacket\rImpacket is a collection of Python classes for working with network protocols.\rPython 11442\r3216\rCon la información obtenida en este proceso, es posible utilizarla para conseguir una sesión interactiva en la máquina comprometida (independiente de la webshell).\nY con esto, se cierra el segundo reto.\nReto 3 - The Glass Tile # Nombre: \u0026ldquo;The Glass Tile\u0026rdquo; Sistema Operativo: Windows Tecnología Web: IIS + ASPX URL: https://challenge-03.makemalware.com Este reto esta pensado para demostrar el potencial del uso de los Tokens de Windows durante el proceso de post-explotación web. La idea surgió a partir de la investigación realizada por mi compañero Kurosh Dabag Escalante: One shell to HANDLE them all.6\nDicho esto, comenzamos visitando la url del reto:\nDe nuevo podemos ver en el código fuente algunas rutas ocultas:\nAl visitar el endpoint /admin encontramos una simple página estática. Parece ser que no tiene mucho más.\nDespliegue de Webshell ASPX # Por otro lado, si visitamos la ruta /upload.aspx volvemos a encontrarnos con una subida arbitraria de archivos.\nAsí que volvemos a subir un agente ASPX de Kraken como en el reto anterior.\nGeneramos un perfil de conexión y, de nuevo, nos conectamos al agente.\nReconocimiento local y Leak de token # Advertimos las mismas políticas del App Locker que impiden la ejecución de comandos:\nNo obstante, al listar los tokens existentes en nuestro proceso, descubrimos uno bajo el contexto de seguridad del usuario WINWS03\\square.\nAl suplantar a dicho usuario podemos comprobar que se trata de un miembro del grupo de Administradores locales de la máquina, y que el token esta en integridad alta.\nLa explicación a esto es que, existe un Directorio Virtual configurado en el IIS. Este directorio virtual apunta a la ruta local: C:/Users/square/adminsite/. Para que el Application Pool Identity pueda acceder a este directorio, necesita un par de credenciales válidas. Para este caso, se han configurado unas en ClearText del usuario WINWS03\\square.\nEl endpoint que gestiona este directorio virtual es /admin, por tanto, cuando se accede a dicho endpoint, el IIS se autentica como el usuario WINWS03\\square para acceder, lo que produce la filtración de un token principal como este usuario.\nElevación de Privilegios con impersonaciones anidadas # A través de la primera suplantación conseguimos elevar privilegios de WINWS03\\webusr a WINWS03\\square (admin local). No obstante, para conseguir el mayor número de privilegios en el equipo, es necesario escalar a SYSTEM.\nPara ello, como se disponen de privilegios de administrador y se esta en integridad alta, se procede a buscar un proceso que corra como SYSTEM. Para ello usamos el módulo ps de Kraken y, entre los distintos procesos, identificamos un candidato: winlogon.exe\nEs bien conocido que, el proceso winlogon, corre con la cuenta del sistema y, además de esto, es posible duplicar su token principal y utilizarlo para la suplantación.\rUtilizando el módulo dup_token de Kraken, conseguimos duplicar el token del winlogon y obtener uno como SYSTEM en nuestro proceso.\nAl utilizar ese token y suplantar a la cuenta del sistema, nos dirigimos al directorio donde se encuentra la flag C:/Users/Administrator/Desktop y, podemos comprobar como al intentar leer la flag, obtenemos un error de \u0026ldquo;permiso denegado\u0026rdquo;.\nEsto se debe a que, existe una ACL configurada en el archivo squid-flag.txt para que sólo pueda ser accesible por su propietario, es decir, WINWS03\\Administrator.\nPara poder establecer esta ACL y eliminar el resto, se han tenido que quitar los \u0026ldquo;permisos heredados\u0026rdquo; del archivo.\rAnte esta configuración, se plantea la posibilidad de suplantar al usuario WINWS03\\Administrator en cuestión. Para poder hacerlo, se revisa de nuevo el listado de procesos, y se encuentra uno prometedor:\nEl proceso con PID: 3132, corresponde a un Procmon64, que se esta ejecutando bajo el directorio C:/Users/Administrator/Downloads/ProcessMonitor, lo que signfica que es posible que dicho usuario haya lanzado el proceso en su logon session.\nSe confirma la premisa a través del duplicado de su token, y de la suplantación haciendo uso del mismo. En este contexto, finalmente se puede acceder a la flag del reto:\nExtracción de secretos a través del módulo de Administración de IIS # Y, por último, para completar la post-explotación, al disponer de privilegios de Administrador e Integridad Alta, es posible extraer los secretos configurados en el IIS utilizando la libreria: Microsoft.Web.Administration (utilizada para la administración del servidor web).\nA través de esta funcionalidad, es posible recuperar las credenciales en plano configuradas para cualquier AppPool, VirtualDirectory o AppPoolIdentity. Para ello, basta con utilizar el módulo de Kraken dump_iis_secrets\nPara desarrollar el módulo de dump_iis_secrets, utilicé la idea descrita por Grzegorz Tworek en uno de sus Tweets7 que habla acerca de la posibilidad de extraer estas credenciales utilizando el binario appcmd.exe.\nConclusiones # Como conclusión, se demuestra el potencial y la comodidad al utilizar Kraken como herramienta de post explotación web. Se han cubierto diferentes explotaciones en diferentes escenarios.\nFinalmente puedes encontrar el código de los retos, así como los comandos utilizados, en el siguiente enlace.\nO bien, puedes descargarte las OVAs de los retos de Mega.\n¡Espero que os haya gustado, y nos vemos en el siguiente post!\nBack To The Future: Unix Wildcards Gone Wild : https://www.exploit-db.com/papers/33930\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nEjecución de código arbitrario utilizando /usr/bin/tar : https://gtfobins.github.io/gtfobins/tar/#shell\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nEl sistema de archivos /proc : https://tldp.org/pub/Linux/docs/ldp-archived/system-admin-guide/translations/es/html/ch04s07.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSSH Public Key Authentication : https://www.ssh.com/academy/ssh/public-key-authentication\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nForced Authentication : https://www.ired.team/offensive-security/initial-access/t1187-forced-authentication\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOne shell to HANDLE them all : https://www.tarlogic.com/es/blog/abuso-handles-token/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n0gtweet IIS Application Pool credential dumping : https://twitter.com/0gtweet/status/1588815661085917186\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 marzo 2023","permalink":"/es/posts/squid-game-ctf/","section":"Posts","summary":"Squid Game es un CTF creado para el congreso: Hc0n 2023. Se trata de tres retos estilo Boot2root a través de un acceso inicial web. El objetivo de los retos es: realizar una post-explotación vía webshell sobre unos entornos restringidos y conseguir ganar privilegios. En este post, se mostrarán las soluciones propuestas para estos retos.","title":"Squid Game CTF - Hc0n 2023"},{"content":"","date":"1 marzo 2023","permalink":"/es/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"1 marzo 2023","permalink":"/es/tags/webshell/","section":"Tags","summary":"","title":"webshell"},{"content":"","date":"17 enero 2023","permalink":"/es/series/kraken-fundamentals/","section":"Series","summary":"","title":"Kraken Fundamentals"},{"content":"\rEn la primera parte de esta serie: \u0026ldquo;Kraken Fundamentals\u0026rdquo;, hablé acerca de lo que es Kraken y su funcionamiento a alto nivel.\nTras esta introducción, en esta segunda parte, presentaré de forma detallada y en profundidad, dos componentes fundamentales en Kraken: los Módulos y los Agentes.\nEl objetivo consiste en explicar su diseño, estructura, funcionamiento y cómo se relacionan entre sí.\nAunque este post será algo más extenso y detallado que el anterior, confio en que sea posible comprender como opera Kraken y la posiblidad de escalarlo ante cualquier necesidad.\nDicho esto, y sin mayor demora\u0026hellip; ¡Comencemos!\nMódulos de Kraken # La primera pregunta que se debe responder al abordar esta sección es la siguiente:\n¿Qué es un módulo? # Los módulos de Kraken son aquellas piezas de código que permiten realizar una o varias acciones sobre el sistema operativo en el cual se ejecuta.\nGeneralmente, un módulo es una clase, en el lenguaje de programación correspondiente, que contiene toda la lógica para cumplir con el propósito con el que se ha desarrollado. Para esto, utiliza todos los recursos disponibles en las librerias del lenguaje y/o en el sistema en el que se encuentra.\nTipos de módulos # Aunque, a nivel práctico no es relevante, a nivel teórico existen dos tipos de módulos en Kraken: los módulos nativos y abstractos.\nLos Módulos Nativos son reimplementaciones (nativas) de comandos del sistema operativo. Permiten obtener información similar a la que se obtendrá ejecutando el comando equivalente al que se pretende imitar.\nEstos módulos pueden ser de gran utilidad en la primera fase de reconocimiento. Pues, en ese momento, se desconoce la posible existencia de soluciones de seguridad u otros productos defensivos. De esta forma, se presenta una alternativa para evitar ser detectados nada más comenzar con la post-explotación.\nNo obstante, la exactitud con la que se puede recrear la funcionalidad de un comando del sistema, dependerá completamente del lenguaje de programación utilizado y del contexto. Pues, en algunas tecnologías puede verse una ausencia de funcionalidades por la incapacidad de realizar según que acciones.\rPor otro lado, los Módulos Abstractos no se corresponden con comandos del sistema, sino que realizan una acción más compleja y que se abstrae del sistema operativo en cuestión. Un ejemplo de comando abstracto podría ser: la subida y descarga de archivos, o por ejemplo, un módulo para realizar un escaneo de puertos local o remoto.\nJerarquía de los módulos # Un detalle importante a conocer acerca de los módulos es: cómo estan organizados. Pues su disposición y convención permite a Kraken seleccionar los módulos que necesita en el momento en el que los precisa.\nPara explicar la jerarquía, tenemos que situarnos en la carpeta modules/ en la raíz del proyecto. Este directorio tiene la siguiente apariencia:\n. └── modules ├── modules.py # config de los módulos ├── template.php # plantillas de ejemplo ├── template.java ├── template.cs └── cd # directorio del módulo ├── cd.cs4.cs # implementación en .NET 4 ├── cd.java1.7.java # implementación en Java 7 ├── cd.java1.8.java ├── cd.php5.php # implementación en PHP 5 ├── cd.php7.php └── cd.php8.php Por un lado, tenemos las plantillas: que son archivos modelo para la creación de módulos en sus respectivos lenguajes. También podemos encontrar el archivo modules.py el cual contiene la definición y configuración de todos los módulos de Kraken (esto lo explicaré más adelante).\nY por otro lado, tenemos diferentes directorios que se corresponden con los módulos que hay disponibles.\nComo se puede observar, dentro de cada uno de estos directorios, se encuentran las diferentes versiones de cada módulo desarrolladas en los lenguajes de programación soportados. La convención de nombres que se sigue es la siguiente:\nEste formato es importante pues:\nPermite la separación entre los lenguajes de programación utilizados (ya que hay módulos que sólo estan disponibles en determinados lenguajes). Facilita el versionado de los módulos que permite contemplar diferentes implementaciones en función de la versión del lenguaje de programación o tecnología (esto es útil de cara a la retrocompatibilidad, pues si utilizamos funciones del lenguaje relativamente nuevas, nuestro módulos no funcionarán en versiones anteriores). Para aquellos módulos cuya implementación no difiera en distintas versiones, se mantiene el mismo contenido pero utilizando un enlace simbólico para evitar el duplicado de archivos. Con esta información, Kraken, en tiempo de ejecución sabe, con qué tipo de agente se esta comunicando, y es capaz de ofrecer al operador aquellos módulos que puedan ser ejecutados en el contexto en el que se encuentra.\nUn ejemplo de esto es: si no dispones del módulo \u0026ldquo;ls\u0026rdquo; para la versión 5.4 de PHP, Kraken no te lo mostrará en la tty. En cambio, si tienes un módulo para todas las subversiones de PHP 5, entonces Kraken si te permitirá utilizarlo.\nEstructura de un módulo # La estructura de los módulos de Kraken puede variar ligeramente entre lenguajes de programación (pues cada uno tiene sus métodos de carga y eso afecta a su implementación), no obstante, los módulos se han diseñado para que sigan una idea común.\nPara mostrar este patrón entre módulos, se utilizará como ejemplo la plantilla Java actual:\nimport java.io.*; import java.util.*; import java.text.*; import javax.xml.bind.*; import java.util.regex.*; public class Module_template { private final String SUCC_CODE = \u0026#34;0\u0026#34;; private final String ERR_CODE = \u0026#34;1\u0026#34;; private final String JAVA_EOL = System.lineSeparator(); private String hex2str(String data) { byte[] data_bytes = DatatypeConverter.parseHexBinary(data); String data_string = new String(data_bytes); return data_string; } private String normalizePath(String currPath) { currPath = currPath.replace(\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); currPath = currPath.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#34;); currPath = currPath.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;); return currPath; } private String[] parseArgs(String args) { String regex = \u0026#34;\\\u0026#34;[^\\\u0026#34;]+\\\u0026#34;|\u0026#39;[^\u0026#39;]+\u0026#39;|\\\\S+\u0026#34;; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(args); List\u0026lt;String\u0026gt; arguments = new ArrayList\u0026lt;String\u0026gt;(); while (matcher.find()) arguments.add(matcher.group(0)); String[] arguments_arr = new String[arguments.size()]; arguments_arr = arguments.toArray(arguments_arr); return arguments_arr; } private String changeCWD(String cwd) throws Exception { File target_dir = new File(cwd).getAbsoluteFile(); if (target_dir.exists() == false) throw new Exception(\u0026#34;Directory: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: does not exist\u0026#34;); if (target_dir.canRead() == false) throw new Exception(\u0026#34;Can\u0026#39;t move to path: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: permission denied\u0026#34;); if (target_dir.isDirectory() == false) throw new Exception(\u0026#34;Path: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: is not a directory\u0026#34;); System.setProperty(\u0026#34;user.dir\u0026#34;, target_dir.getCanonicalPath()); return normalizePath(target_dir.getCanonicalPath()); } private String[] doAction(String param_one, String param_two, String param_three) { String output = \u0026#34;\u0026#34;; try { output = \u0026#34;do something\u0026#34; + JAVA_EOL; } catch(Exception ex) { return new String[]{ERR_CODE, ex.ToString() + JAVA_EOL}; } return new String[]{SUCC_CODE, output}; } public String[] execute(String[] args) { if (args.length != 1) return new String[]{ERR_CODE, \u0026#34;Invalid arguments provided. Only one directory is allowed to be moved\u0026#34; + JAVA_EOL}; return doAction(args[0]); } public String[] go(String module_cwd, String module_args) { try { String new_cwd = changeCWD(hex2str(module_cwd)); String[] args = parseArgs(hex2str(module_args)); return execute(args); } catch(Exception ex) { return new String[]{ERR_CODE, ex.getMessage() + JAVA_EOL}; } } public static void main(String[] args) { Module_template m = new Module_template(); String[] results = m.execute(args); System.out.println(results[1]); return; } } Tras examinar el código de la plantilla, se destacan algunos aspectos de interés:\nEl módulo consta de una Clase, la cual es instanciada e invocada (el modo dependerá del ejecutor utilizado en cada tecnología) pero en todas se sigue esta línea. En esta clase podemos ver un método \u0026ldquo;main\u0026rdquo; el cuál es importante pues, el módulo debe poderse compilar en local y ejecutarse. De esta forma, puedes mantener una estructura cómun que te permita que los mismo módulos que Kraken invoca, sean facilmente compilables y ejecutables en local (obviamente con sus modificaciones pertinentes). Los módulos, deben tener un método público: go() que permita pasar los argumentos necesarios desde el agente al módulo. El flujo de esta función es el siguiente: Con hex2str(), obtenemos los valores de los argumentos que se pasan en formato hexadecimal al módulo. Con changeCWD() se establece el \u0026ldquo;Current Working Directory\u0026rdquo; (cwd) del módulo. Pues el cambio entre directorios se tiene que mantener en el cliente y enviar la referencia al agente. Después se procesan los argumentos con parseArgs(), que los devuelve en un array listos para ser utilizados por el módulo. Finalmente, se llama al método execute() que se encargará de procesar los argumentos e invocar a la función que realiza la acción objetivo. El concepto de esta función go() es similar a cómo se utiliza en los BOF de Cobaltstrike1.\nEs importante destacar que: en el caso de PHP, la función go() es suprimida debido a que, el ejecutor que hay por defecto en PHP, evalua el código del módulo tal cual. Esto hace que no sea necesario instanciar la clase y llamar al método (como haríamos en Java o .NET) sino ejecutar el código directamente.\rTras esto, se acaba llamando a la función do...() que se encargará de realizar las acciones para las cuales se ha desarrollado el módulo. Este método devolverá un array con dos elementos: El ćodigo de retorno o estado (status_code): el que indica si la ejecución ha sido exitosa o no. El resultado como contenido del mensaje a mostrar (message). Por último, tanto las funciones previas al doAction() de este ejemplo, como los atributos de la clase, serán elementos imprescindibles para que los módulos funcionen. Por ello es importante utilizar las plantillas disponibles para que los módulos sigan el mismo formato. En futuros posts hablaré acerca de la creación de los módulos (y otros elementos de Kraken) y cómo utilizarlos.\nConfiguración de los módulos # Ahora bien, los módulos de Kraken, no son sólo archivos de código, pues también deben aportar unas características para poder ser utilizados, por ejemplo:\n¿Qué argumentos necesita? ¿Y de qué tipo? ¿Para qué tecnologías esta disponible? ¿Se puede utilizar en cualquier Sistema Operativo? ¿Cómo debe funcionar el módulo? ¿Debe interactuar con algún elemento del cliente? ¿Cómo se debe mostrar el resultado de la ejecución? Estas y más preguntas son respondidas en el archivo: modules/modules.py que hemos mencionado anteriormente.\nPor medio de esta estructura en lenguaje Python, Kraken es capaz de entender cómo debe tratar a cada módulo existente. Para mostrar cada uno de los campos, se utilizará la configuración relativa al módulo ls como ejemplo:\n{ \u0026#34;name\u0026#34; : \u0026#34;ls\u0026#34;, \u0026#34;template\u0026#34; : \u0026#34;ls\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;List files or directories\u0026#34;, \u0026#34;author\u0026#34; : \u0026#34;@secu_x11\u0026#34;, \u0026#34;examples\u0026#34; : [ \u0026#34;ls\u0026#34;, \u0026#34;ls ..\u0026#34;, \u0026#34;ls /etc\u0026#34;, \u0026#34;ls -R /etc\u0026#34;, \u0026#34;ls C:/Users\u0026#34; ], \u0026#34;so\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;Linux\u0026#34;, \u0026#34;agents\u0026#34; : [\u0026#34;php\u0026#34;,\u0026#34;java\u0026#34;] }, { \u0026#34;name\u0026#34; : \u0026#34;Windows\u0026#34;, \u0026#34;agents\u0026#34; : [\u0026#34;php\u0026#34;,\u0026#34;java\u0026#34;,\u0026#34;cs\u0026#34;] } ], \u0026#34;args\u0026#34; : [ { \u0026#34;-R\u0026#34;: { \u0026#34;help\u0026#34;: \u0026#34;Recursive mode\u0026#34;, \u0026#34;action\u0026#34; : \u0026#34;store_true\u0026#34;, \u0026#34;required\u0026#34;: 0 }, \u0026#34;files\u0026#34;: { \u0026#34;help\u0026#34;: \u0026#34;Files to list\u0026#34;, \u0026#34;nargs\u0026#34; : \u0026#34;*\u0026#34;, \u0026#34;type\u0026#34;: str } } ], \u0026#34;dispatcher\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;formater\u0026#34; : \u0026#34;columns\u0026#34; } A continuación se detallan algunos de los campos que pueden despertar preguntas:\nTemplate: corresponde al nombre de la plantilla que se utilizará en la jerarquía de archivos del directorio modules/ (este suele/debe coincidir con el nombre del módulo en cuestión). Sistema Operativo: aquí se plasma la información acerca de los sistemas operativos y tecnologías para los cuales esta soportado el módulo. Argumentos: lo único a destacar acerca de este campo, es que los argumentos son definidos con la estructura que utiliza argparser. De esta forma, se puede delegar la validación de los argumentos a esta librería. Dispatcher: aquí figura el nombre del componente que se encargará de definir cómo es procesado el módulo por el Cliente de Kraken (de esto se hablará más adelante). Formater: de igual forma que con el dispatcher, el formater es un componente que define como deben mostrarse los resultados que devuelve el agente. Otras consideraciones # Otro detalle de importancia es que, gracias a esta jerarquía, el operador puede hacer \u0026ldquo;edición en caliente\u0026rdquo; de los módulos.\nPor ejemplo, puede suceder que, se desarrolle un módulo de post-explotación para Kraken, y\u0026hellip; al ejecutarse, este no devuelva la información que se espera o directamente falle. En ese caso, es posible editar el contenido del módulo en disco y volver a ejecutarlo (en PHP y .NET) o recompilarlo (en Java).\nDe esta forma, se aporta una cierta flexibilidad al operador que puede ajustar su intrusión al entorno en el que se encuentra.\nAgentes de Kraken # Para que los módulos sean ejecutados y se obtenga la respuesta, estos deben ser recibidos y procesados por el otro componente fundamental en Kraken: los Agentes.\n¿Qué es un Agente? # Un Agente de Kraken es un archivo que se situa en un directorio accesible del servicio web y permite la carga de módulos de Kraken. Para ello, recibe, procesa e interpreta el contenido de los módulos y argumentos necesarios para su correcta ejecución.\nTipos de Agentes # Actualmente, los agentes se pueden encontrar bajo el directorio agents/. Existen 2 tipos de agentes que son:\nAgentes Standard: para utilizar con el modo st. Agentes Command-and-Control: para utilizar con el modo c2. Bajo el subdirectorio c2/ simplemente se encuentra un sólo agente, ya que en este momento sólo me ha dado tiempo de realizar la implementación en PHP. Este modo es \u0026ldquo;experimental\u0026rdquo; y aún no ha sido testeado por completo. No obstante es usable y funciona correctamente.\nPor otro lado, en el subdirectorio st/ podemos encontrar 3 versiones de agentes que se corresponden a las tecnologías disponibles: PHP, Java y .NET\nEn futuras versiones de Kraken, se añadirá la posibilidad de utilizar un generador de Webshells que permita seleccionar entre distintos tipos de Webshells en función del entorno y características que se desea. Por ahora, las webshells/agentes disponibles son fijas y deben modificarse algunos campos en su interior para customizar su uso.\rEstructura general # La estructura del Agente varía en función de su tipo. Aunque, al igual que los módulos, estos siguen un mismo patrón. El siguiente diagrama muestra, de forma simplificada, el flujo de un Agente de Kraken:\ngraph TD; A[Agente] --\u003e|Recibe petición HTTP| B{Autenticación} B --\u003e |Incorrecta| C(Devolver Respuesta) B --\u003e |Correcta| D[Handle] D --\u003e E{Extracción de \\nParámetros} E --\u003e |Inválidos| C E --\u003e |Válidos| F{Comprobar Código \\nde Acción} F --\u003e |Inexistente| C F --\u003e |Existente| G[Invocar Acción] G --\u003e H[Extracción de \\nla Respuesta] H --\u003e C Los agentes realizan una rigurosa comprobación de los parámetros encapsulados en la petición HTTP. Pues, a partir de estos, se realizan las acciones en función de los valores contenidos en los mismos.\nAlgunos elementos destacables en el agente son:\nAutenticación: el primer paso para que la comunicación entre Cliente y Agente de Kraken sea exitosa, consiste en un proceso de autenticación mediante una clave simétrica: La clave debe ser conocida por el Agente y por el Cliente (de esto se hablará en profundidad en el siguiente post). La misma clave de autenticación se utiliza para cifrar el contenido de los módulos y argumentos. El proceso de cifrado y descifrado es una simple operación XOR sobre el valor la clave elegida en ambos extremos. Extracción de Parámetros: tanto el módulo como los argumentos necesarios, son encapsulados en la petición HTTP por parte del Cliente. Al igual que este encapsula, el Agente deberá conocer dónde son incrustados pues tiene que realizar su proceso inverso para obtenerlos. Esta información es relativa a los Perfiles de Conexión que se explicarán más adelante: Códigos de Acciones: los agentes tienen varios tipos de acciones, estos son indicados en función de un valor entero que se envia por el Cliente. Aunque se entrará en detalle en los siguientes posts, se citan a continuación los posibles valores:\nConsulta de Estado (STATUS) Carga de módulos (LOAD) Invocación de módulo (INVOKE) Descarga de módulo (UNLOAD) Limpieza de módulos (CLEAN) Invocación: una vez se ha decidido que acción realizar, se procede a su invocación. En este caso, lo más relevante es hablar acerca de la acción \u0026ldquo;INVOKE\u0026rdquo;, que es la que se utiliza para ejecutar el módulo enviado por el cliente:\nEjecutores disponibles # Los encargados de realizar esta evaluación o ejecución del módulo recibido toman el nombre de Ejecutores.\nCada ejecutor tiene su forma particular de tratar al módulo y, dependiendo de este, el cliente tendrá que enviarlo en el formato adecuado. Por ello es importante elegir bien el agente utilizado a la hora de su despliegue.\nLos ejecutores utilizan las funciones de la tecnología en uso para conseguir ejecutar el código del módulo. Actualmente el listado de los que son soportados es el siguiente:\nNota: obviamente hay más funcionalidades que te permiten ejecutar código2 en estos tres lenguajes de programación pero, para este momento, se ha decidido centrar los esfuerzos en uno de ellos suficientemente versátil para poner el foco en otros puntos de mayor interés.\nAl momento de realizar su invocación, se pasan los argumentos requeridos directamente al módulo de la forma indicada. Para este caso se ejemplificará con el ejecutor por defecto del agente Standard en Java:\nEl resultante de la ejecución es un array de dos elementos del tipo String que contiene el código de estado (return code) y el resultado de la ejecución (message). Con estos datos, se puede retornar la respuesta al Cliente encapsulando la información en su lugar correspondiente.\nAl recibirla, el Cliente determinará como mostrar esta respuesta, pero esto ya es otra historia por contar.\nConclusiones # Llegados a este punto, se concluye esta segunda parte de la serie. Obviamente, aun quedan muchas dudas por resolver y muchos conceptos por explicar.\nEn el siguiente post hablaré acerca de los 2 modos que existen actualmente en Kraken (ST y C2). También explicaré en profundidad cómo es la comunicación entre Cliente y Agente. Desglosando la estructura del paso de mensajes que se utiliza y mostrando todo el potencial que aporta.\n¡Espero que os haya gustado el post y nos vemos muy pronto!\nCobaltStrike Beacon Object File (BOF) : https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAlternative code execution methods in Java: https://medium.com/@m01e/jsp-webshell-cookbook-part-1-6836844ceee7\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"17 enero 2023","permalink":"/es/posts/kraken-fundamentals-2/","section":"Posts","summary":"Dos piezas fundamentales en la lógica de Kraken son los Módulos y los Agentes. A través de estos componentes, se entenderá como Kraken realiza la ejecución de código y aprovecha su diseño y arquitectura para aportar al operador cierta flexibilidad y comodidad durante la fase de post-explotación.","title":"Kraken Fundamentals - II"},{"content":"","date":"17 enero 2023","permalink":"/es/categories/persistence/","section":"Categories","summary":"","title":"Persistence"},{"content":"","date":"17 enero 2023","permalink":"/es/series/","section":"Series","summary":"","title":"Series"},{"content":"\rComenzamos un nuevo año y con ello se presentan nuevas oportunidades y nuevos retos!\nQuiero comenzar este 2023 presentando un proyecto en el que llevo trabajando más de un año. Y el cuál será presentado en la próxima Hackplayers Conference (Hc0n) que se celebrará los días 24 y 25 de Febrero en La Nave (Madrid).\nPara comenzar con la explicación, primero necesito \u0026ldquo;hacer un seek al inicio\u0026rdquo;, dónde comenzó todo y empezar a contar desde ahí.\nEste será el primero de una serie de posts dónde hablaré acerca de Kraken, de cómo funciona internamente y cómo puede utilizarse.\nAsí que, pilla algo para picar y… ¡comencémos!\nIntroducción # Durante uno de mis ejercicios de Red Team, conseguí comprometer varias plataformas web del perímetro del cliente. La vulnerabilidad que exploté me permitió desplegar una Webshell1 en cada uno de los servidores comprometidos.\nLa razón de desplegar una webshell en lugar de utilizar otro vector, es que se aporta tanto un vector de ejecución (\rTA0002) como una forma de mantener el acceso al equipo comprometido (\rTA0003).\nLlegados a este punto, iba a comenzar con la fase de reconocimiento, como bien estaba acostumbrado a hacer. No obstante, tras comentar los hallazgos con mis compañeros, se me advirtió de la posible existencia de EDR’s2 en los equipos comprometidos.\nYa que, al tratarse de máquinas expuestas a Internet (Endpoint3), debían tener una política de Hardening4 más robusta que otros equipos de la organización.\nFue en este momento cuando se me planteó el primer problema:\n¿Cómo verificar esta premisa sin llamar demasiado la atención?\n— (pues la ejecución de comandos del sistema, muy probablemente este monitorizada)\nPara dar solución a este problema, implementé rápidamente una prueba de concepto de “webshell” que me permitiera realizar operaciones básicas sobre el sistema para poder hacer la comprobación.\nTras utilizarla en uno de los equipos comprometidos, pude confirmar que, efectivamente, había en funcionamiento un agente Linux de un EDR muy conocido.\nCon esto, la situación se complicaba, pues se sabía de antemano que dicho producto detectaría cualquier intento de enumeración tradicional desde la webshell.\nY aquí se planteaba la siguiente pregunta:\n¿Cómo proceder a realizar un reconocimiento completo sin ser detectados?\nY de la respuesta a esta pregunta, nació una versión muy minimalista de lo que es hoy Kraken.\n¿Qué es Kraken? # Kraken es una herramienta que te permite controlar webshells en múltiples lenguajes de programación. Se podría decir que es algo así como un “orquestador de webshells”.\nAhora bien, el objetivo que Kraken persigue es: dar la capacidad de operar de la forma más silenciosa posible. Utilizando, para ello, todos los recursos que el lenguaje y el sistema en uso te proporcionan.\n¿Cómo funciona Kraken? # El flujo de ejecución de Kraken se podría simplificar en el siguiente diagrama:\nPor un lado tenemos la parte del Cliente: que se trata de un script en Python que se puede utilizar para generar webshells y conectarse con las mismas una vez estan desplegadas.\nY por otro lado, se encuentra el Agente con el que conseguimos ejecutar los módulos que nos permitirán obtener la información que buscamos durante el proceso de reconocimiento.\nMás adelante profundizaremos en todos estos componentes que intervienen en el funcionamiento de la herramienta y el motivo por el que estan ahí.\n¿Qué lenguajes soporta Kraken? # Actualmente, Kraken soporta:\nPHP (para servicios web en PHP) Java (para JSP) .NET (para ASPX) Obviamente esto es sólo una parte de todas las tecnologías web disponibles actualmente, no obstante, se ha optado por cubrir estas tres, ya que son las más habituales y me permite abordar mejor los problemas que van surgiendo durante el desarrollo.\nPues\u0026hellip; el que mucho abarca, poco aprieta.\n— Refranero popular\nPor otro lado, los agentes o webshells de Kraken, se han probado en los sistemas operativos:\nWindows (en diferentes versiones) Linux (en diferentes distribuciones) Entonces, una pregunta que surge (o lleva desde el inicio presente) es la siguiente:\n¿Qué lo hace diferente de otras webshells conocidas? # Kraken reune un conjunto de características que han sido pensadas para mejorar el uso de la herramienta y aportar una visión diferente del uso de las webshells. Algunas de las características que la hacen diferente a otras herramientas son:\nSe evita la ejecución de comandos del sistema (su característica principal y el propósito por el que se desarrolló). Esta propiedad la hace muy útil en sistemas donde hay una monitorización activa o existen soluciones de seguridad que pueden detectar nuestra presencia. Su diseño modular presenta algunas ventajas y fortalezas frente a otras herramientas:\nPermite manter un sistema de multi-versión con el cual, se determina en tiempo de ejecución, aquellos módulos que pueden cargarse en función de la información que reporta el agente con el que se comunica. La jerarquía elegida para el sistema de módulos permite la edicción en caliente de los módulos en uso. De igual forma, es posible registrar módulos sin detener la ejecución del programa. El desarrollo de cada módulo busca conseguir explotar al máximo las características del lenguaje para conseguir la mejor recreación de los comandos a los que se calca. Esto tiende a generar módulos más grandes pero con mejores resultados. Las plantillas que se proporcionan para cada lenguaje, hacen que resulte sencillo extender la funcionalidad de Kraken y crear nuevos módulos. Al tratarse los módulos como archivos, se evita la \u0026ldquo;duplicidad\u0026rdquo; de los mismos a partir del uso de enlaces simbólicos (para casos en los que la implementación no varía dependiendo de la versión). Kraken proporciona un sistema de Cross-Compiling sin dependencias añadidas que permite que, para los casos en los que sea necesario, se puedan compilar los módulos sin necesidad de preocuparse de disponer de los requerimientos instalados en la máquina. Esto se ha conseguido gracias a la integración con Docker5.\nActualmente, existen dos modos de utilizar Kraken:\nEl Modo \u0026ldquo;Standard\u0026rdquo; (ST): que es el modo tradicional del que funcionan las webshells (estilo petición-invocación-respuesta). El Modo \u0026ldquo;Command-and-Control\u0026rdquo; (C2): cuyo funcionamiento es similar al de un C2 utilizando el método de carga-invocación-descarga de módulos utilizando variables de sesión (se entrará en detalle en futuros posts). Flexibilidad en la comunicación mediante el uso de perfiles de conexión. Es posible detallar toda la información acerca de cómo va a ser la comunicación entre cliente y agente a partir de un archivo JSON que sigue un esquema concreto.\nAdiccionalmente, Kraken también proporciona utilidades como:\nUna pseudo-terminal con las capacidades básicas de una consola. Control de errores en Agentes, Módulos y Cliente. Sistema de Logging e Histórico integrados. Y otras utilidades relacionadas con la herramienta. Conclusiones # Con esto llegamos al final de la primera parte. En los siguientes post profundizaré acerca de la estructura interna de Kraken, los elementos que infieren en su funcionamiento así como ejemplos prácticos de uso. Así que ¡no te pierdas lo que esta por venir!\nEspero que te haya gustado y ¡nos vemos pronto!\n¿Qué es una Webshell? : https://www.imperva.com/learn/application-security/web-shell/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n¿Qué es un EDR? : https://www.crowdstrike.com/cybersecurity-101/endpoint-security/endpoint-detection-and-response-edr/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n¿Qué es un Endpoint? : https://www.paloaltonetworks.com/cyberpedia/what-is-an-endpoint\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n¿Qué es el Hardening? : https://www.beyondtrust.com/resources/glossary/systems-hardening\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n¿Qué es Docker? : https://www.docker.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"9 enero 2023","permalink":"/es/posts/kraken-fundamentals-1/","section":"Posts","summary":"Kraken es una herramienta para orquestar webshells desarrolladas en PHP, Java y .NET. Este es el primer post de la serie Kraken Fundamentals, donde hablaremos acerca de cómo esta diseñada y cómo funciona la herramienta.","title":"Kraken Fundamentals - I"},{"content":"","date":"9 enero 2023","permalink":"/es/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"Desde que empecé en el mundo de la seguridad, no he dejado de investigar, desarrollar y compartir. A continuación encontrarás algunos de los proyectos e investigaciones a los que más tiempo he dedicado.\nHerramientas Logo Título Descripción Enlace Kraken Una webshell modular y multi-lenguaje (PHP, JSP, ASPX) enfocada a la post-explotación web y la evasión de defensas. repositorio Mistica Una navaja suiza de código abierto para la comunicación arbitraria a través de protocolos de aplicación. repositorio Conferencias Logo Título Tipo Descripción Defcon31 DemoLabs, 2023 Taller Kraken, a modular multi-language webshell for defense evasion EuskalHack, 2023 Taller Practical Exploitation with Kraken Hc0n, 2023 Charla Kraken - una webshell modular y multi-lenguaje Navaja Negra, 2022 Taller Diseña y despliega tu propia infraestructura privada BlackHat Arsenal USA, 2020 Charla Mística: Cualquier cosa es un túnel si eres lo suficientemente valiente - ¡Canales encubiertos para todos! Bitup Alicante, 2020 Charla Canales encubiertos con Mistica Otros Logo Title Description Link LAB.LOCAL A fictitious example of the design and implementation of an organization's Infrastructure. repository CiberReserva Bitup Alicante 2021 CTF Final Challenge, which simulates a Red Team exercise. repository ","date":"27 diciembre 2022","permalink":"/es/projects/","section":"MakeMalware","summary":"Desde que empecé en el mundo de la seguridad, no he dejado de investigar, desarrollar y compartir. A continuación encontrarás algunos de los proyectos e investigaciones a los que más tiempo he dedicado.","title":"Proyectos"},{"content":"\rExperiencia Empresa Enlace Rol Fecha Localización Telefonica Tech Offensive Security Engineer 04/2023 - Actual Madrid, ES BlackArrow (Tarlogic) Analísta de Red Team 10/2021 - 12/2022 Madrid, ES INCIDE Digital Data SL Analísta de Red Team 02/2019 - 10/2021 Barcelona, ES ZATACA SYSTEMS, S.L Consultor de ciberseguridad 01/2018 - 10/2018 Elche, ES BitUp Alicante Co-organizador de Comunidad de Ciberseguridad 10/2017 - 10/2021 Alicante, ES Certificaciones Logo Empresa Certificación Fecha Pentester Academy Certified Red Team Expert (CRTE) 03/2022 Offensive Security Offensive Security Certified Proffesional (OSCP) 07/2021 Educación Centro Enlace Titulación Fecha Universidad Internacional de La Rioja Ingeniería Informática 2020 - Present Universidad de Alicante Ingeniería Informática 2016 - 2020 ","date":"27 diciembre 2022","permalink":"/es/resume/","section":"MakeMalware","summary":"Experiencia Empresa Enlace Rol Fecha Localización Telefonica Tech Offensive Security Engineer 04/2023 - Actual Madrid, ES BlackArrow (Tarlogic) Analísta de Red Team 10/2021 - 12/2022 Madrid, ES INCIDE Digital Data SL Analísta de Red Team 02/2019 - 10/2021 Barcelona, ES ZATACA SYSTEMS, S.","title":"Resumen"},{"content":"Me llamo Raúl Caro Teixidó (aka Secu) y me encanta desarrollar, investigar y romper todo tipo de cosas relacionadas con la ciberseguridad.\nEmpecé en el mundo de la seguridad en el 2017, cuando estaba en el instituto y tenía mucho tiempo para leer y aprender. En 2018 comencé mi primer trabajo como consultor de Ciberseguridad, y a día de hoy sumo más de 4 años de experiencia trabajando como Analista de Red Team (Incide y Blackarrow).\nActualmente, dedico mi tiempo libre a mejorar/crear herramientas que me puedan ser útiles en mi trabajo, así como mejorar mis habilidades en Red Team. Me gusta compartir lo que aprendo pues\u0026hellip; a fin de cuentas\u0026hellip;\n¿No somos todos fruto de lo que hemos aprendido de los demás?\nPara cualquier cosa, no dudes en ponerte en contacto conmigo a través de mi Twitter o por Linkedin.\n","date":"27 diciembre 2022","permalink":"/es/about/","section":"MakeMalware","summary":"Me llamo Raúl Caro Teixidó (aka Secu) y me encanta desarrollar, investigar y romper todo tipo de cosas relacionadas con la ciberseguridad.\nEmpecé en el mundo de la seguridad en el 2017, cuando estaba en el instituto y tenía mucho tiempo para leer y aprender.","title":"Sobre mi"}]