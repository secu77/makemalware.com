[{"content":"","date":"17 enero 2023","permalink":"/es/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"17 enero 2023","permalink":"/es/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"17 enero 2023","permalink":"/es/categories/defense-evasion/","section":"Categories","summary":"","title":"Defense Evasion"},{"content":"","date":"17 enero 2023","permalink":"/es/tags/kraken/","section":"Tags","summary":"","title":"kraken"},{"content":"","date":"17 enero 2023","permalink":"/es/series/kraken-fundamentals/","section":"Series","summary":"","title":"Kraken Fundamentals"},{"content":" En la primera parte de esta serie: \u0026ldquo;Kraken Fundamentals\u0026rdquo;, hablé acerca de lo que es Kraken y su funcionamiento a alto nivel.\nTras esta introducción, en esta segunda parte, presentaré de forma detallada y en profundidad, dos componentes fundamentales en Kraken: los Módulos y los Agentes.\nEl objetivo consiste en explicar su diseño, estructura, funcionamiento y cómo se relacionan entre sí.\nAunque este post será algo más extenso y detallado que el anterior, confio en que sea posible comprender como opera Kraken y la posiblidad de escalarlo ante cualquier necesidad.\nDicho esto, y sin mayor demora\u0026hellip; ¡Comencemos!\nMódulos de Kraken\u003e Módulos de Kraken # La primera pregunta que se debe responder al abordar esta sección es la siguiente:\n¿Qué es un módulo?\u003e ¿Qué es un módulo? # Los módulos de Kraken son aquellas piezas de código que permiten realizar una o varias acciones sobre el sistema operativo en el cual se ejecuta.\nGeneralmente, un módulo es una clase, en el lenguaje de programación correspondiente, que contiene toda la lógica para cumplir con el propósito con el que se ha desarrollado. Para esto, utiliza todos los recursos disponibles en las librerias del lenguaje y/o en el sistema en el que se encuentra.\nTipos de módulos\u003e Tipos de módulos # Aunque, a nivel práctico no es relevante, a nivel teórico existen dos tipos de módulos en Kraken: los módulos nativos y abstractos.\nLos Módulos Nativos son reimplementaciones (nativas) de comandos del sistema operativo. Permiten obtener información similar a la que se obtendrá ejecutando el comando equivalente al que se pretende imitar.\nEstos módulos pueden ser de gran utilidad en la primera fase de reconocimiento. Pues, en ese momento, se desconoce la posible existencia de soluciones de seguridad u otros productos defensivos. De esta forma, se presenta una alternativa para evitar ser detectados nada más comenzar con la post-explotación.\nNo obstante, la exactitud con la que se puede recrear la funcionalidad de un comando del sistema, dependerá completamente del lenguaje de programación utilizado y del contexto. Pues, en algunas tecnologías puede verse una ausencia de funcionalidades por la incapacidad de realizar según que acciones. Por otro lado, los Módulos Abstractos no se corresponden con comandos del sistema, sino que realizan una acción más compleja y que se abstrae del sistema operativo en cuestión. Un ejemplo de comando abstracto podría ser: la subida y descarga de archivos, o por ejemplo, un módulo para realizar un escaneo de puertos local o remoto.\nJerarquía de los módulos\u003e Jerarquía de los módulos # Un detalle importante a conocer acerca de los módulos es: cómo estan organizados. Pues su disposición y convención permite a Kraken seleccionar los módulos que necesita en el momento en el que los precisa.\nPara explicar la jerarquía, tenemos que situarnos en la carpeta modules/ en la raíz del proyecto. Este directorio tiene la siguiente apariencia:\n. └── modules ├── modules.py # config de los módulos ├── template.php # plantillas de ejemplo ├── template.java ├── template.cs └── cd # directorio del módulo ├── cd.cs4.cs # implementación en .NET 4 ├── cd.java1.7.java # implementación en Java 7 ├── cd.java1.8.java ├── cd.php5.php # implementación en PHP 5 ├── cd.php7.php └── cd.php8.php Por un lado, tenemos las plantillas: que son archivos modelo para la creación de módulos en sus respectivos lenguajes. También podemos encontrar el archivo modules.py el cual contiene la definición y configuración de todos los módulos de Kraken (esto lo explicaré más adelante).\nY por otro lado, tenemos diferentes directorios que se corresponden con los módulos que hay disponibles.\nComo se puede observar, dentro de cada uno de estos directorios, se encuentran las diferentes versiones de cada módulo desarrolladas en los lenguajes de programación soportados. La convención de nombres que se sigue es la siguiente:\nEste formato es importante pues:\nPermite la separación entre los lenguajes de programación utilizados (ya que hay módulos que sólo estan disponibles en determinados lenguajes). Facilita el versionado de los módulos que permite contemplar diferentes implementaciones en función de la versión del lenguaje de programación o tecnología (esto es útil de cara a la retrocompatibilidad, pues si utilizamos funciones del lenguaje relativamente nuevas, nuestro módulos no funcionarán en versiones anteriores). Para aquellos módulos cuya implementación no difiera en distintas versiones, se mantiene el mismo contenido pero utilizando un enlace simbólico para evitar el duplicado de archivos. Con esta información, Kraken, en tiempo de ejecución sabe, con qué tipo de agente se esta comunicando, y es capaz de ofrecer al operador aquellos módulos que puedan ser ejecutados en el contexto en el que se encuentra.\nUn ejemplo de esto es: si no dispones del módulo \u0026ldquo;ls\u0026rdquo; para la versión 5.4 de PHP, Kraken no te lo mostrará en la tty. En cambio, si tienes un módulo para todas las subversiones de PHP 5, entonces Kraken si te permitirá utilizarlo.\nEstructura de un módulo\u003e Estructura de un módulo # La estructura de los módulos de Kraken puede variar ligeramente entre lenguajes de programación (pues cada uno tiene sus métodos de carga y eso afecta a su implementación), no obstante, los módulos se han diseñado para que sigan una idea común.\nPara mostrar este patrón entre módulos, se utilizará como ejemplo la plantilla Java actual:\nimport java.io.*; import java.util.*; import java.text.*; import javax.xml.bind.*; import java.util.regex.*; public class Module_template { private final String SUCC_CODE = \u0026#34;0\u0026#34;; private final String ERR_CODE = \u0026#34;1\u0026#34;; private final String JAVA_EOL = System.lineSeparator(); private String hex2str(String data) { byte[] data_bytes = DatatypeConverter.parseHexBinary(data); String data_string = new String(data_bytes); return data_string; } private String normalizePath(String currPath) { currPath = currPath.replace(\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); currPath = currPath.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#34;); currPath = currPath.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;); return currPath; } private String[] parseArgs(String args) { String regex = \u0026#34;\\\u0026#34;[^\\\u0026#34;]+\\\u0026#34;|\u0026#39;[^\u0026#39;]+\u0026#39;|\\\\S+\u0026#34;; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(args); List\u0026lt;String\u0026gt; arguments = new ArrayList\u0026lt;String\u0026gt;(); while (matcher.find()) arguments.add(matcher.group(0)); String[] arguments_arr = new String[arguments.size()]; arguments_arr = arguments.toArray(arguments_arr); return arguments_arr; } private String changeCWD(String cwd) throws Exception { File target_dir = new File(cwd).getAbsoluteFile(); if (target_dir.exists() == false) throw new Exception(\u0026#34;Directory: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: does not exist\u0026#34;); if (target_dir.canRead() == false) throw new Exception(\u0026#34;Can\u0026#39;t move to path: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: permission denied\u0026#34;); if (target_dir.isDirectory() == false) throw new Exception(\u0026#34;Path: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: is not a directory\u0026#34;); System.setProperty(\u0026#34;user.dir\u0026#34;, target_dir.getCanonicalPath()); return normalizePath(target_dir.getCanonicalPath()); } private String[] doAction(String param_one, String param_two, String param_three) { String output = \u0026#34;\u0026#34;; try { output = \u0026#34;do something\u0026#34; + JAVA_EOL; } catch(Exception ex) { return new String[]{ERR_CODE, ex.ToString() + JAVA_EOL}; } return new String[]{SUCC_CODE, output}; } public String[] execute(String[] args) { if (args.length != 1) return new String[]{ERR_CODE, \u0026#34;Invalid arguments provided. Only one directory is allowed to be moved\u0026#34; + JAVA_EOL}; return doAction(args[0]); } public String[] go(String module_cwd, String module_args) { try { String new_cwd = changeCWD(hex2str(module_cwd)); String[] args = parseArgs(hex2str(module_args)); return execute(args); } catch(Exception ex) { return new String[]{ERR_CODE, ex.getMessage() + JAVA_EOL}; } } public static void main(String[] args) { Module_template m = new Module_template(); String[] results = m.execute(args); System.out.println(results[1]); return; } } Tras examinar el código de la plantilla, se destacan algunos aspectos de interés:\nEl módulo consta de una Clase, la cual es instanciada e invocada (el modo dependerá del ejecutor utilizado en cada tecnología) pero en todas se sigue esta línea. En esta clase podemos ver un método \u0026ldquo;main\u0026rdquo; el cuál es importante pues, el módulo debe poderse compilar en local y ejecutarse. De esta forma, puedes mantener una estructura cómun que te permita que los mismo módulos que Kraken invoca, sean facilmente compilables y ejecutables en local (obviamente con sus modificaciones pertinentes). Los módulos, deben tener un método público: go() que permita pasar los argumentos necesarios desde el agente al módulo. El flujo de esta función es el siguiente: Con hex2str(), obtenemos los valores de los argumentos que se pasan en formato hexadecimal al módulo. Con changeCWD() se establece el \u0026ldquo;Current Working Directory\u0026rdquo; (cwd) del módulo. Pues el cambio entre directorios se tiene que mantener en el cliente y enviar la referencia al agente. Después se procesan los argumentos con parseArgs(), que los devuelve en un array listos para ser utilizados por el módulo. Finalmente, se llama al método execute() que se encargará de procesar los argumentos e invocar a la función que realiza la acción objetivo. El concepto de esta función go() es similar a cómo se utiliza en los BOF de Cobaltstrike1.\nEs importante destacar que: en el caso de PHP, la función go() es suprimida debido a que, el ejecutor que hay por defecto en PHP, evalua el código del módulo tal cual. Esto hace que no sea necesario instanciar la clase y llamar al método (como haríamos en Java o .NET) sino ejecutar el código directamente. Tras esto, se acaba llamando a la función do...() que se encargará de realizar las acciones para las cuales se ha desarrollado el módulo. Este método devolverá un array con dos elementos: El ćodigo de retorno o estado (status_code): el que indica si la ejecución ha sido exitosa o no. El resultado como contenido del mensaje a mostrar (message). Por último, tanto las funciones previas al doAction() de este ejemplo, como los atributos de la clase, serán elementos imprescindibles para que los módulos funcionen. Por ello es importante utilizar las plantillas disponibles para que los módulos sigan el mismo formato. En futuros posts hablaré acerca de la creación de los módulos (y otros elementos de Kraken) y cómo utilizarlos.\nConfiguración de los módulos\u003e Configuración de los módulos # Ahora bien, los módulos de Kraken, no son sólo archivos de código, pues también deben aportar unas características para poder ser utilizados, por ejemplo:\n¿Qué argumentos necesita? ¿Y de qué tipo? ¿Para qué tecnologías esta disponible? ¿Se puede utilizar en cualquier Sistema Operativo? ¿Cómo debe funcionar el módulo? ¿Debe interactuar con algún elemento del cliente? ¿Cómo se debe mostrar el resultado de la ejecución? Estas y más preguntas son respondidas en el archivo: modules/modules.py que hemos mencionado anteriormente.\nPor medio de esta estructura en lenguaje Python, Kraken es capaz de entender cómo debe tratar a cada módulo existente. Para mostrar cada uno de los campos, se utilizará la configuración relativa al módulo ls como ejemplo:\n{ \u0026#34;name\u0026#34; : \u0026#34;ls\u0026#34;, \u0026#34;template\u0026#34; : \u0026#34;ls\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;List files or directories\u0026#34;, \u0026#34;author\u0026#34; : \u0026#34;@secu_x11\u0026#34;, \u0026#34;examples\u0026#34; : [ \u0026#34;ls\u0026#34;, \u0026#34;ls ..\u0026#34;, \u0026#34;ls /etc\u0026#34;, \u0026#34;ls -R /etc\u0026#34;, \u0026#34;ls C:/Users\u0026#34; ], \u0026#34;so\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;Linux\u0026#34;, \u0026#34;agents\u0026#34; : [\u0026#34;php\u0026#34;,\u0026#34;java\u0026#34;] }, { \u0026#34;name\u0026#34; : \u0026#34;Windows\u0026#34;, \u0026#34;agents\u0026#34; : [\u0026#34;php\u0026#34;,\u0026#34;java\u0026#34;,\u0026#34;cs\u0026#34;] } ], \u0026#34;args\u0026#34; : [ { \u0026#34;-R\u0026#34;: { \u0026#34;help\u0026#34;: \u0026#34;Recursive mode\u0026#34;, \u0026#34;action\u0026#34; : \u0026#34;store_true\u0026#34;, \u0026#34;required\u0026#34;: 0 }, \u0026#34;files\u0026#34;: { \u0026#34;help\u0026#34;: \u0026#34;Files to list\u0026#34;, \u0026#34;nargs\u0026#34; : \u0026#34;*\u0026#34;, \u0026#34;type\u0026#34;: str } } ], \u0026#34;dispatcher\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;formater\u0026#34; : \u0026#34;columns\u0026#34; } A continuación se detallan algunos de los campos que pueden despertar preguntas:\nTemplate: corresponde al nombre de la plantilla que se utilizará en la jerarquía de archivos del directorio modules/ (este suele/debe coincidir con el nombre del módulo en cuestión). Sistema Operativo: aquí se plasma la información acerca de los sistemas operativos y tecnologías para los cuales esta soportado el módulo. Argumentos: lo único a destacar acerca de este campo, es que los argumentos son definidos con la estructura que utiliza argparser. De esta forma, se puede delegar la validación de los argumentos a esta librería. Dispatcher: aquí figura el nombre del componente que se encargará de definir cómo es procesado el módulo por el Cliente de Kraken (de esto se hablará más adelante). Formater: de igual forma que con el dispatcher, el formater es un componente que define como deben mostrarse los resultados que devuelve el agente. Otras consideraciones\u003e Otras consideraciones # Otro detalle de importancia es que, gracias a esta jerarquía, el operador puede hacer \u0026ldquo;edición en caliente\u0026rdquo; de los módulos.\nPor ejemplo, puede suceder que, se desarrolle un módulo de post-explotación para Kraken, y\u0026hellip; al ejecutarse, este no devuelva la información que se espera o directamente falle. En ese caso, es posible editar el contenido del módulo en disco y volver a ejecutarlo (en PHP y .NET) o recompilarlo (en Java).\nDe esta forma, se aporta una cierta flexibilidad al operador que puede ajustar su intrusión al entorno en el que se encuentra.\nAgentes de Kraken\u003e Agentes de Kraken # Para que los módulos sean ejecutados y se obtenga la respuesta, estos deben ser recibidos y procesados por el otro componente fundamental en Kraken: los Agentes.\n¿Qué es un Agente?\u003e ¿Qué es un Agente? # Un Agente de Kraken es un archivo que se situa en un directorio accesible del servicio web y permite la carga de módulos de Kraken. Para ello, recibe, procesa e interpreta el contenido de los módulos y argumentos necesarios para su correcta ejecución.\nTipos de Agentes\u003e Tipos de Agentes # Actualmente, los agentes se pueden encontrar bajo el directorio agents/. Existen 2 tipos de agentes que son:\nAgentes Standard: para utilizar con el modo st. Agentes Command-and-Control: para utilizar con el modo c2. Bajo el subdirectorio c2/ simplemente se encuentra un sólo agente, ya que en este momento sólo me ha dado tiempo de realizar la implementación en PHP. Este modo es \u0026ldquo;experimental\u0026rdquo; y aún no ha sido testeado por completo. No obstante es usable y funciona correctamente.\nPor otro lado, en el subdirectorio st/ podemos encontrar 3 versiones de agentes que se corresponden a las tecnologías disponibles: PHP, Java y .NET\nEn futuras versiones de Kraken, se añadirá la posibilidad de utilizar un generador de Webshells que permita seleccionar entre distintos tipos de Webshells en función del entorno y características que se desea. Por ahora, las webshells/agentes disponibles son fijas y deben modificarse algunos campos en su interior para customizar su uso. Estructura general\u003e Estructura general # La estructura del Agente varía en función de su tipo. Aunque, al igual que los módulos, estos siguen un mismo patrón. El siguiente diagrama muestra, de forma simplificada, el flujo de un Agente de Kraken:\ngraph TD; A[Agente] --\u003e|Recibe petición HTTP| B{Autenticación} B --\u003e |Incorrecta| C(Devolver Respuesta) B --\u003e |Correcta| D[Handle] D --\u003e E{Extracción de \\nParámetros} E --\u003e |Inválidos| C E --\u003e |Válidos| F{Comprobar Código \\nde Acción} F --\u003e |Inexistente| C F --\u003e |Existente| G[Invocar Acción] G --\u003e H[Extracción de \\nla Respuesta] H --\u003e C Los agentes realizan una rigurosa comprobación de los parámetros encapsulados en la petición HTTP. Pues, a partir de estos, se realizan las acciones en función de los valores contenidos en los mismos.\nAlgunos elementos destacables en el agente son:\nAutenticación: el primer paso para que la comunicación entre Cliente y Agente de Kraken sea exitosa, consiste en un proceso de autenticación mediante una clave simétrica: La clave debe ser conocida por el Agente y por el Cliente (de esto se hablará en profundidad en el siguiente post). La misma clave de autenticación se utiliza para cifrar el contenido de los módulos y argumentos. El proceso de cifrado y descifrado es una simple operación XOR sobre el valor la clave elegida en ambos extremos. Extracción de Parámetros: tanto el módulo como los argumentos necesarios, son encapsulados en la petición HTTP por parte del Cliente. Al igual que este encapsula, el Agente deberá conocer dónde son incrustados pues tiene que realizar su proceso inverso para obtenerlos. Esta información es relativa a los Perfiles de Conexión que se explicarán más adelante: Códigos de Acciones: los agentes tienen varios tipos de acciones, estos son indicados en función de un valor entero que se envia por el Cliente. Aunque se entrará en detalle en los siguientes posts, se citan a continuación los posibles valores:\nConsulta de Estado (STATUS) Carga de módulos (LOAD) Invocación de módulo (INVOKE) Descarga de módulo (UNLOAD) Limpieza de módulos (CLEAN) Invocación: una vez se ha decidido que acción realizar, se procede a su invocación. En este caso, lo más relevante es hablar acerca de la acción \u0026ldquo;INVOKE\u0026rdquo;, que es la que se utiliza para ejecutar el módulo enviado por el cliente:\nEjecutores disponibles\u003e Ejecutores disponibles # Los encargados de realizar esta evaluación o ejecución del módulo recibido toman el nombre de Ejecutores.\nCada ejecutor tiene su forma particular de tratar al módulo y, dependiendo de este, el cliente tendrá que enviarlo en el formato adecuado. Por ello es importante elegir bien el agente utilizado a la hora de su despliegue.\nLos ejecutores utilizan las funciones de la tecnología en uso para conseguir ejecutar el código del módulo. Actualmente el listado de los que son soportados es el siguiente:\nNota: obviamente hay más funcionalidades que te permiten ejecutar código2 en estos tres lenguajes de programación pero, para este momento, se ha decidido centrar los esfuerzos en uno de ellos suficientemente versátil para poner el foco en otros puntos de mayor interés.\nAl momento de realizar su invocación, se pasan los argumentos requeridos directamente al módulo de la forma indicada. Para este caso se ejemplificará con el ejecutor por defecto del agente Standard en Java:\nEl resultante de la ejecución es un array de dos elementos del tipo String que contiene el código de estado (return code) y el resultado de la ejecución (message). Con estos datos, se puede retornar la respuesta al Cliente encapsulando la información en su lugar correspondiente.\nAl recibirla, el Cliente determinará como mostrar esta respuesta, pero esto ya es otra historia por contar.\nConclusiones\u003e Conclusiones # Llegados a este punto, se concluye esta segunda parte de la serie. Obviamente, aun quedan muchas dudas por resolver y muchos conceptos por explicar.\nEn el siguiente post hablaré acerca de los 2 modos que existen actualmente en Kraken (ST y C2). También explicaré en profundidad cómo es la comunicación entre Cliente y Agente. Desglosando la estructura del paso de mensajes que se utiliza y mostrando todo el potencial que aporta.\n¡Espero que os haya gustado el post y nos vemos muy pronto!\nCobaltStrike Beacon Object File (BOF) : https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAlternative code execution methods in Java: https://medium.com/@m01e/jsp-webshell-cookbook-part-1-6836844ceee7\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"17 enero 2023","permalink":"/es/posts/kraken-fundamentals-2/","section":"Posts","summary":"Dos piezas fundamentales en la lógica de Kraken son los Módulos y los Agentes. A través de estos componentes, se entenderá como Kraken realiza la ejecución de código y aprovecha su diseño y arquitectura para aportar al operador cierta flexibilidad y comodidad durante la fase de post-explotación.","title":"Kraken Fundamentals - II"},{"content":"","date":"17 enero 2023","permalink":"/es/","section":"MakeMalware","summary":"","title":"MakeMalware"},{"content":"","date":"17 enero 2023","permalink":"/es/categories/persistence/","section":"Categories","summary":"","title":"Persistence"},{"content":"","date":"17 enero 2023","permalink":"/es/tags/redteam/","section":"Tags","summary":"","title":"redteam"},{"content":"","date":"17 enero 2023","permalink":"/es/authors/secu/","section":"Authors","summary":"","title":"secu"},{"content":"","date":"17 enero 2023","permalink":"/es/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"17 enero 2023","permalink":"/es/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"17 enero 2023","permalink":"/es/tags/webshell/","section":"Tags","summary":"","title":"webshell"},{"content":" Comenzamos un nuevo año y con ello se presentan nuevas oportunidades y nuevos retos!\nQuiero comenzar este 2023 presentando un proyecto en el que llevo trabajando más de un año. Y el cuál será presentado en la próxima Hackplayers Conference (Hc0n) que se celebrará los días 24 y 25 de Febrero en La Nave (Madrid).\nPara comenzar con la explicación, primero necesito \u0026ldquo;hacer un seek al inicio\u0026rdquo;, dónde comenzó todo y empezar a contar desde ahí.\nEste será el primero de una serie de posts dónde hablaré acerca de Kraken, de cómo funciona internamente y cómo puede utilizarse.\nAsí que, pilla algo para picar y… ¡comencémos!\nIntroducción\u003e Introducción # Durante uno de mis ejercicios de Red Team, conseguí comprometer varias plataformas web del perímetro del cliente. La vulnerabilidad que exploté me permitió desplegar una Webshell1 en cada uno de los servidores comprometidos.\nLa razón de desplegar una webshell en lugar de utilizar otro vector, es que se aporta tanto un vector de ejecución ( TA0002) como una forma de mantener el acceso al equipo comprometido ( TA0003).\nLlegados a este punto, iba a comenzar con la fase de reconocimiento, como bien estaba acostumbrado a hacer. No obstante, tras comentar los hallazgos con mis compañeros, se me advirtió de la posible existencia de EDR’s2 en los equipos comprometidos.\nYa que, al tratarse de máquinas expuestas a Internet (Endpoint3), debían tener una política de Hardening4 más robusta que otros equipos de la organización.\nFue en este momento cuando se me planteó el primer problema:\n¿Cómo verificar esta premisa sin llamar demasiado la atención?\n— (pues la ejecución de comandos del sistema, muy probablemente este monitorizada)\nPara dar solución a este problema, implementé rápidamente una prueba de concepto de “webshell” que me permitiera realizar operaciones básicas sobre el sistema para poder hacer la comprobación.\nTras utilizarla en uno de los equipos comprometidos, pude confirmar que, efectivamente, había en funcionamiento un agente Linux de un EDR muy conocido.\nCon esto, la situación se complicaba, pues se sabía de antemano que dicho producto detectaría cualquier intento de enumeración tradicional desde la webshell.\nY aquí se planteaba la siguiente pregunta:\n¿Cómo proceder a realizar un reconocimiento completo sin ser detectados?\nY de la respuesta a esta pregunta, nació una versión muy minimalista de lo que es hoy Kraken.\n¿Qué es Kraken?\u003e ¿Qué es Kraken? # Kraken es una herramienta que te permite controlar webshells en múltiples lenguajes de programación. Se podría decir que es algo así como un “orquestador de webshells”.\nAhora bien, el objetivo que Kraken persigue es: dar la capacidad de operar de la forma más silenciosa posible. Utilizando, para ello, todos los recursos que el lenguaje y el sistema en uso te proporcionan.\n¿Cómo funciona Kraken?\u003e ¿Cómo funciona Kraken? # El flujo de ejecución de Kraken se podría simplificar en el siguiente diagrama:\nPor un lado tenemos la parte del Cliente: que se trata de un script en Python que se puede utilizar para generar webshells y conectarse con las mismas una vez estan desplegadas.\nY por otro lado, se encuentra el Agente con el que conseguimos ejecutar los módulos que nos permitirán obtener la información que buscamos durante el proceso de reconocimiento.\nMás adelante profundizaremos en todos estos componentes que intervienen en el funcionamiento de la herramienta y el motivo por el que estan ahí.\n¿Qué lenguajes soporta Kraken?\u003e ¿Qué lenguajes soporta Kraken? # Actualmente, Kraken soporta:\nPHP (para servicios web en PHP) Java (para JSP) .NET (para ASPX) Obviamente esto es sólo una parte de todas las tecnologías web disponibles actualmente, no obstante, se ha optado por cubrir estas tres, ya que son las más habituales y me permite abordar mejor los problemas que van surgiendo durante el desarrollo.\nPues\u0026hellip; el que mucho abarca, poco aprieta.\n— Refranero popular\nPor otro lado, los agentes o webshells de Kraken, se han probado en los sistemas operativos:\nWindows (en diferentes versiones) Linux (en diferentes distribuciones) Entonces, una pregunta que surge (o lleva desde el inicio presente) es la siguiente:\n¿Qué lo hace diferente de otras webshells conocidas?\u003e ¿Qué lo hace diferente de otras webshells conocidas? # Kraken reune un conjunto de características que han sido pensadas para mejorar el uso de la herramienta y aportar una visión diferente del uso de las webshells. Algunas de las características que la hacen diferente a otras herramientas son:\nSe evita la ejecución de comandos del sistema (su característica principal y el propósito por el que se desarrolló). Esta propiedad la hace muy útil en sistemas donde hay una monitorización activa o existen soluciones de seguridad que pueden detectar nuestra presencia. Su diseño modular presenta algunas ventajas y fortalezas frente a otras herramientas:\nPermite manter un sistema de multi-versión con el cual, se determina en tiempo de ejecución, aquellos módulos que pueden cargarse en función de la información que reporta el agente con el que se comunica. La jerarquía elegida para el sistema de módulos permite la edicción en caliente de los módulos en uso. De igual forma, es posible registrar módulos sin detener la ejecución del programa. El desarrollo de cada módulo busca conseguir explotar al máximo las características del lenguaje para conseguir la mejor recreación de los comandos a los que se calca. Esto tiende a generar módulos más grandes pero con mejores resultados. Las plantillas que se proporcionan para cada lenguaje, hacen que resulte sencillo extender la funcionalidad de Kraken y crear nuevos módulos. Al tratarse los módulos como archivos, se evita la \u0026ldquo;duplicidad\u0026rdquo; de los mismos a partir del uso de enlaces simbólicos (para casos en los que la implementación no varía dependiendo de la versión). Kraken proporciona un sistema de Cross-Compiling sin dependencias añadidas que permite que, para los casos en los que sea necesario, se puedan compilar los módulos sin necesidad de preocuparse de disponer de los requerimientos instalados en la máquina. Esto se ha conseguido gracias a la integración con Docker5.\nActualmente, existen dos modos de utilizar Kraken:\nEl Modo \u0026ldquo;Standard\u0026rdquo; (ST): que es el modo tradicional del que funcionan las webshells (estilo petición-invocación-respuesta). El Modo \u0026ldquo;Command-and-Control\u0026rdquo; (C2): cuyo funcionamiento es similar al de un C2 utilizando el método de carga-invocación-descarga de módulos utilizando variables de sesión (se entrará en detalle en futuros posts). Flexibilidad en la comunicación mediante el uso de perfiles de conexión. Es posible detallar toda la información acerca de cómo va a ser la comunicación entre cliente y agente a partir de un archivo JSON que sigue un esquema concreto.\nAdiccionalmente, Kraken también proporciona utilidades como:\nUna pseudo-terminal con las capacidades básicas de una consola. Control de errores en Agentes, Módulos y Cliente. Sistema de Logging e Histórico integrados. Y otras utilidades relacionadas con la herramienta. Conclusiones\u003e Conclusiones # Con esto llegamos al final de la primera parte. En los siguientes post profundizaré acerca de la estructura interna de Kraken, los elementos que infieren en su funcionamiento así como ejemplos prácticos de uso. Así que ¡no te pierdas lo que esta por venir!\nEspero que te haya gustado y ¡nos vemos pronto!\n¿Qué es una Webshell? : https://www.imperva.com/learn/application-security/web-shell/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n¿Qué es un EDR? : https://www.crowdstrike.com/cybersecurity-101/endpoint-security/endpoint-detection-and-response-edr/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n¿Qué es un Endpoint? : https://www.paloaltonetworks.com/cyberpedia/what-is-an-endpoint\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n¿Qué es el Hardening? : https://www.beyondtrust.com/resources/glossary/systems-hardening\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n¿Qué es Docker? : https://www.docker.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"9 enero 2023","permalink":"/es/posts/kraken-fundamentals-1/","section":"Posts","summary":"Kraken es una herramienta para orquestar webshells desarrolladas en PHP, Java y .NET. Este es el primer post de la serie Kraken Fundamentals, donde hablaremos acerca de cómo esta diseñada y cómo funciona la herramienta.","title":"Kraken Fundamentals - I"},{"content":"","date":"9 enero 2023","permalink":"/es/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"Desde que empecé en el mundo de la seguridad, no he dejado de investigar, desarrollar y compartir. A continuación encontrarás algunos de los proyectos e investigaciones a los que más tiempo he dedicado.\nHerramientas\u003e Herramientas Logo Título Descripción Enlace Kraken Una webshell modular y multi-lenguaje. repositorio Mistica Una navaja suiza de código abierto para la comunicación arbitraria a través de protocolos de aplicación. repositorio Conferencias\u003e Conferencias Logo Título Tipo Descripción Hc0n, 2023 Charla Kraken - una webshell modular y multi-lenguaje Navaja Negra, 2022 Taller Diseña y despliega tu propia infraestructura privada BlackHat Arsenal, 2022 Charla Mística: Cualquier cosa es un túnel si eres lo suficientemente valiente - ¡Canales encubiertos para todos! Bitup Alicante, 2020 Charla Canales encubiertos con Mistica Otros\u003e Otros Logo Title Description Link LAB.LOCAL A fictitious example of the design and implementation of an organization's Infrastructure. repository CiberReserva Bitup Alicante 2021 CTF Final Challenge, which simulates a Red Team exercise. repository ","date":"27 diciembre 2022","permalink":"/es/projects/","section":"MakeMalware","summary":"Desde que empecé en el mundo de la seguridad, no he dejado de investigar, desarrollar y compartir. A continuación encontrarás algunos de los proyectos e investigaciones a los que más tiempo he dedicado.","title":"Proyectos"},{"content":"Experiencia\u003e Experiencia Empresa Enlace Rol Fecha Localización BlackArrow (Tarlogic) Analísta de Red Team 10/2021 - 12/2022 Madrid, ES INCIDE Digital Data SL Analísta de Red Team 02/2019 - 10/2021 Barcelona, ES ZATACA SYSTEMS, S.L Consultor de ciberseguridad 01/2018 - 10/2018 Elche, ES BitUp Alicante Co-organizador de Comunidad de Ciberseguridad 10/2017 - 10/2021 Alicante, ES Certificaciones\u003e Certificaciones Logo Empresa Certificación Fecha Pentester Academy Certified Red Team Expert (CRTE) 03/2022 Offensive Security Offensive Security Certified Proffesional (OSCP) 07/2021 Educación\u003e Educación Centro Enlace Titulación Fecha Universidad Internacional de La Rioja Ingeniería Informática 2020 - Present Universidad de Alicante Ingeniería Informática 2016 - 2020 ","date":"27 diciembre 2022","permalink":"/es/resume/","section":"MakeMalware","summary":"Experiencia\u003e Experiencia Empresa Enlace Rol Fecha Localización BlackArrow (Tarlogic) Analísta de Red Team 10/2021 - 12/2022 Madrid, ES INCIDE Digital Data SL Analísta de Red Team 02/2019 - 10/2021 Barcelona, ES ZATACA SYSTEMS, S.","title":"Resumen"},{"content":"Me llamo Raúl Caro Teixidó (aka Secu) y me encanta desarrollar, investigar y romper todo tipo de cosas relacionadas con la ciberseguridad.\nEmpecé en el mundo de la seguridad en el 2017, cuando estaba en el instituto y tenía mucho tiempo para leer y aprender. En 2018 comencé mi primer trabajo como consultor de Ciberseguridad, y a día de hoy sumo más de 4 años de experiencia trabajando como Analista de Red Team (Incide y Blackarrow).\nActualmente, dedico mi tiempo libre a mejorar/crear herramientas que me puedan ser útiles en mi trabajo, así como mejorar mis habilidades en Red Team. Me gusta compartir lo que aprendo pues\u0026hellip; a fin de cuentas\u0026hellip;\n¿No somos todos fruto de lo que hemos aprendido de los demás?\nPara cualquier cosa, no dudes en ponerte en contacto conmigo a través de mi Twitter o por Linkedin.\n","date":"27 diciembre 2022","permalink":"/es/about/","section":"MakeMalware","summary":"Me llamo Raúl Caro Teixidó (aka Secu) y me encanta desarrollar, investigar y romper todo tipo de cosas relacionadas con la ciberseguridad.\nEmpecé en el mundo de la seguridad en el 2017, cuando estaba en el instituto y tenía mucho tiempo para leer y aprender.","title":"Sobre mi"}]