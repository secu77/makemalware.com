[{"content":" ","date":"17 January 2023","permalink":"/","section":"","summary":" ","title":""},{"content":"","date":"17 January 2023","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"17 January 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"17 January 2023","permalink":"/categories/defense-evasion/","section":"Categories","summary":"","title":"Defense Evasion"},{"content":"","date":"17 January 2023","permalink":"/tags/kraken/","section":"Tags","summary":"","title":"kraken"},{"content":"","date":"17 January 2023","permalink":"/series/kraken-fundamentals/","section":"Series","summary":"","title":"Kraken Fundamentals"},{"content":" In the first part of this series: \u0026ldquo;Kraken Fundamentals\u0026rdquo;, I talked about what Kraken is and how it works at a high level.\nAfter this introduction, in this second part, I will present in detail and in depth, two fundamental components in Kraken: Modules and Agents.\nThe objective is to explain their design, structure, operation and how they relate to each other.\nAlthough this post will be a little longer and more detailed than the previous one, I hope that it will be possible to understand how Kraken operates and the possibility of scaling it to any need.\nAnd after this\u0026hellip; Let\u0026rsquo;s get started!\nKraken modules\u003e Kraken modules # The first question to answer when approaching this section is the following:\nWhat is a module?\u003e What is a module? # Kraken modules are those pieces of code that allow you to perform one or more actions on the operating system on which it runs.\nGenerally, a module is a class, in the corresponding programming language, that contains all the logic to fulfill the purpose for which it has been developed. For this, it uses all the resources available in the language libraries and/or in the system in which it is located.\nTypes of modules\u003e Types of modules # Although, it is practically irrelevant, but theoretically there are two types of modules in Kraken: native and abstract modules.\nNative Modules are (native) re-implementations of operating system commands. They allow to obtain information similar to that displayed by a system command, that is being imitated, when executed.\nThese modules can be very useful in the first reconnaissance phase. At that time, the possible existence of security solutions or other defensive products is unknown. In this way, an alternative is presented to avoid detection as soon as post-exploitation begins.\nHowever, the accuracy with which the functionality of a system command can be recreated depends entirely on the programming language used and the context. In some technologies, there may be a lack of functionality due to the inability to perform certain actions. On the other hand, Abstract Modules do not correspond to system commands, but perform a more complex action that is abstracted from the operating system. An example of an abstract command could be: the action to upload and download files, or for example, a module to perform a local or remote port scan.\nHierarchy of the modules\u003e Hierarchy of the modules # An important detail to know about the modules is: \u0026ldquo;how they are organized\u0026rdquo;. Because their arrangement allows Kraken to select the modules it needs when it needs them.\nTo explain the hierarchy, we have to go to the modules/ folder in the root of the project. This directory looks like this:\n. └── modules ├── modules.py # module configuration ├── template.php # example templates ├── template.java ├── template.cs └── cd # module directory ├── cd.cs4.cs # implementation in .NET 4 ├── cd.java1.7.java # implementation in Java 7 ├── cd.java1.8.java ├── cd.php5.php # implementation in PHP 5 ├── cd.php7.php └── cd.php8.php On the one hand, we have the templates: which are model files for the creation of modules in their respective languages. We can also find the modules.py file which contains the definition and configuration of all Kraken modules (I will explain this later).\nAnd on the other hand, we have different directories that correspond to the modules available in Kraken.\nAs you can see, inside each of these directories, you can find the different versions of each module developed in the supported programming languages. The naming convention is as follows:\nThis format is important because:\nIt allows the separation between the programming languages used (because there are modules that are only available in certain languages). It facilitates the versioning of the modules that allows to keep different implementations depending on the version of the programming language or technology (this is useful for backward compatibility, because if we use relatively new language functions, our modules will not work in previous versions). For those modules whose implementation does not differ in different versions, the same content is maintained but using a symbolic link to avoid duplicate files. With this information, Kraken, at runtime, knows what type of agent it is communicating with, and is able to offer the operator those modules that can be executed in the context in which it is.\nAn example of this is: if you do not have the module \u0026ldquo;ls\u0026rdquo; for PHP version 5.4, Kraken will not show it in the tty. On the other hand, if you have a module for all PHP 5 subversions, then Kraken will allow you to use it.\nModule structure\u003e Module structure # The structure of Kraken modules may vary slightly between programming languages (as each has its own loading methods and this affects their implementation), however, the modules have been designed to follow a common idea.\nTo show this pattern between modules, the current Java template will be used as an example:\nimport java.io.*; import java.util.*; import java.text.*; import javax.xml.bind.*; import java.util.regex.*; public class Module_template { private final String SUCC_CODE = \u0026#34;0\u0026#34;; private final String ERR_CODE = \u0026#34;1\u0026#34;; private final String JAVA_EOL = System.lineSeparator(); private String hex2str(String data) { byte[] data_bytes = DatatypeConverter.parseHexBinary(data); String data_string = new String(data_bytes); return data_string; } private String normalizePath(String currPath) { currPath = currPath.replace(\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); currPath = currPath.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#34;); currPath = currPath.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;); return currPath; } private String[] parseArgs(String args) { String regex = \u0026#34;\\\u0026#34;[^\\\u0026#34;]+\\\u0026#34;|\u0026#39;[^\u0026#39;]+\u0026#39;|\\\\S+\u0026#34;; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(args); List\u0026lt;String\u0026gt; arguments = new ArrayList\u0026lt;String\u0026gt;(); while (matcher.find()) arguments.add(matcher.group(0)); String[] arguments_arr = new String[arguments.size()]; arguments_arr = arguments.toArray(arguments_arr); return arguments_arr; } private String changeCWD(String cwd) throws Exception { File target_dir = new File(cwd).getAbsoluteFile(); if (target_dir.exists() == false) throw new Exception(\u0026#34;Directory: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: does not exist\u0026#34;); if (target_dir.canRead() == false) throw new Exception(\u0026#34;Can\u0026#39;t move to path: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: permission denied\u0026#34;); if (target_dir.isDirectory() == false) throw new Exception(\u0026#34;Path: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: is not a directory\u0026#34;); System.setProperty(\u0026#34;user.dir\u0026#34;, target_dir.getCanonicalPath()); return normalizePath(target_dir.getCanonicalPath()); } private String[] doAction(String param_one, String param_two, String param_three) { String output = \u0026#34;\u0026#34;; try { output = \u0026#34;do something\u0026#34; + JAVA_EOL; } catch(Exception ex) { return new String[]{ERR_CODE, ex.ToString() + JAVA_EOL}; } return new String[]{SUCC_CODE, output}; } public String[] execute(String[] args) { if (args.length != 1) return new String[]{ERR_CODE, \u0026#34;Invalid arguments provided. Only one directory is allowed to be moved\u0026#34; + JAVA_EOL}; return doAction(args[0]); } public String[] go(String module_cwd, String module_args) { try { String new_cwd = changeCWD(hex2str(module_cwd)); String[] args = parseArgs(hex2str(module_args)); return execute(args); } catch(Exception ex) { return new String[]{ERR_CODE, ex.getMessage() + JAVA_EOL}; } } public static void main(String[] args) { Module_template m = new Module_template(); String[] results = m.execute(args); System.out.println(results[1]); return; } } After examining the template code, some aspects of interest will be highlighted:\nThe module consists of a Class, which is instantiated and invoked (the way will depend on the executor used in each technology) but all of them follow this line. In this class we can see a \u0026ldquo;main\u0026rdquo; method which is important because, the module must be able to be compiled locally and executed. In this way, you can maintain a common structure that allows the same modules that Kraken invokes, to be easily compiled and executed locally (obviously with its pertinent modifications). The modules must have a public method: go() that allows passing the necessary arguments from the agent to the module. The flow of this function is the following: With hex2str(), we obtain the values of the arguments that are passed in hexadecimal format to the module. With changeCWD() the \u0026ldquo;Current Working Directory\u0026rdquo; (cwd) of the module is set. The change between directories has to be maintained in the client and send the reference to the agent. Then, the arguments are processed with parseArgs(), which returns them in an array ready to be used by the module. Finally, the execute() method is called, which will process the arguments and invoke the function that performs the target action. The concept of this go() function is similar to how it is used in Cobaltstrike BOF\u0026rsquo;s1.\nIt is important to note that, in the case of PHP, the go() function is suppressed because the default PHP executor evaluates the module code as is. This makes it unnecessary to instantiate the class and call the method (as we would do in Java or .NET) but to execute the code directly. After this, the do...() function is called, which will be used to perform the actions for which the module has been developed. This method will return an array with two elements: The return code (status_code): the one that indicates whether the execution has been successful or not. The result as the content of the message to be displayed (message). Finally, both the functions previous to the doAction() of this example, as well as the attributes of the class, will be essential elements for the modules to work. Therefore, it is important to use the available templates so that the modules follow the same format. In future posts I will talk about the creation of modules (and other Kraken elements) and how to use them.\nModule configuration\u003e Module configuration # Now, Kraken modules are not just code files, they must also provide some characteristics to be used, for example:\nWhat arguments do you need, and what type? For which technologies is it available? Can it be used on any operating system? How should the module work? Should it interact with any element of the client? How should the result of the execution be displayed? These and more questions are answered in the file: modules/modules.py mentioned above.\nUsing this Python language structure, Kraken is able to understand how it should handle each existing module. To show each of the fields, the configuration related to the ls module will be used as an example:\n{ \u0026#34;name\u0026#34; : \u0026#34;ls\u0026#34;, \u0026#34;template\u0026#34; : \u0026#34;ls\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;List files or directories\u0026#34;, \u0026#34;author\u0026#34; : \u0026#34;@secu_x11\u0026#34;, \u0026#34;examples\u0026#34; : [ \u0026#34;ls\u0026#34;, \u0026#34;ls ..\u0026#34;, \u0026#34;ls /etc\u0026#34;, \u0026#34;ls -R /etc\u0026#34;, \u0026#34;ls C:/Users\u0026#34; ], \u0026#34;so\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;Linux\u0026#34;, \u0026#34;agents\u0026#34; : [\u0026#34;php\u0026#34;,\u0026#34;java\u0026#34;] }, { \u0026#34;name\u0026#34; : \u0026#34;Windows\u0026#34;, \u0026#34;agents\u0026#34; : [\u0026#34;php\u0026#34;,\u0026#34;java\u0026#34;,\u0026#34;cs\u0026#34;] } ], \u0026#34;args\u0026#34; : [ { \u0026#34;-R\u0026#34;: { \u0026#34;help\u0026#34;: \u0026#34;Recursive mode\u0026#34;, \u0026#34;action\u0026#34; : \u0026#34;store_true\u0026#34;, \u0026#34;required\u0026#34;: 0 }, \u0026#34;files\u0026#34;: { \u0026#34;help\u0026#34;: \u0026#34;Files to list\u0026#34;, \u0026#34;nargs\u0026#34; : \u0026#34;*\u0026#34;, \u0026#34;type\u0026#34;: str } } ], \u0026#34;dispatcher\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;formater\u0026#34; : \u0026#34;columns\u0026#34; } Here are some of the fields that may cause questions:\nTemplate: corresponds to the name of the template to be used in the file hierarchy of the modules/ directory (this usually/must match the name of the module in question). Operating System: here is the information about the operating systems and technologies for which the module is supported. Arguments: the only thing to note about this field is that the arguments are defined with the structure used by argparser. In this way, the validation of the arguments can be delegated to this library. Dispatcher: here is the name of the component that will be responsible for defining how the module is processed by the Kraken Client (this will be discussed later). Formater: as with the dispatcher, the formater is a component that defines how the results returned by the agent should be displayed. Other considerations\u003e Other considerations # Another important detail is that, thanks to this hierarchy, the operator can \u0026ldquo;hot edit\u0026rdquo; the modules.\nFor example, it can happen that a post-exploitation module is developed for Kraken, and\u0026hellip; when executed, it does not return the expected information or fails directly. In that case, it is possible to edit the content of the module on disk and re-execute it (in PHP and .NET) or recompile it (in Java).\nIn this way, a certain flexibility is provided to the operator who can adjust his intrusion to the environment in which he finds himself.\nKraken agents\u003e Kraken agents # In order for the modules to be executed and the response obtained, they must be received and processed by the other fundamental component in Kraken: the Agents.\nWhat is an Agent?\u003e What is an Agent? # A Kraken Agent is a file that is located in an accessible directory of the web service and allows the loading of Kraken modules. To do this, it receives, processes and interprets the content of the modules and arguments necessary for its proper execution.\nTypes of Agents\u003e Types of Agents # Currently, agents can be found under the agents/ directory. There are 2 types of agents:\nStandard Agents: to use with st mode. Command-and-Control agents: for use with c2 mode. Under the subdirectory c2/ there is only one agent, since at this moment I have only had time to make the implementation in PHP. This mode is \u0026ldquo;experimental\u0026rdquo; and has not yet been fully tested. Nevertheless it is usable and works correctly.\nOn the other hand, in the subdirectory st/ we can find 3 versions of agents that correspond to the available technologies: PHP, Java and .NET.\nIn future versions of Kraken, we will add the possibility of using a webshell generator that allows you to select between different types of webshells depending on the environment and features you want. For now, the available webshells/agents are static and some fields inside them must be modified to customize their use. General structure\u003e General structure # The structure of the Agent varies according to its type. Although, like the modules, they follow the same pattern. The following diagram shows, in a simplified way, the flow of a Kraken Agent:\ngraph TD; A[Agent] --\u003e|Receives HTTP request| B{Authentication} B --\u003e |Wrong| C(Return Response) B --\u003e |Right| D[Handle] D --\u003e E{Parameter \\nextraction} E --\u003e |Invalid| C E --\u003e |Valid| F{Check \\nCode Action} F --\u003e |Nonexistent| C F --\u003e |Existent| G[Invoke Action] G --\u003e H[Extraction of \\nthe Response] H --\u003e C The agents perform a rigorous check of the parameters encapsulated in the HTTP request. Based on these parameters, actions are performed according to the values contained in them.\nSome of the most important elements in the agent are:\nAuthentication: the first step for the communication between Client and Kraken Agent to be successful, consists of an authentication process with symmetric key: The key must be known by the Agent and by the Client (this will be discussed in depth in the next post). The same authentication key is used to encrypt the content of the modules and arguments. The encryption and decryption process is a simple XOR operation on the value of the chosen key at both ends. Parameter Extraction: module and the required arguments are encapsulated in the HTTP request by the Client. As it encapsulates them, the Agent must know where they are embedded because it has to perform the reverse process to obtain them. This information is related to the Connection Profiles that will be explained later: Action Codes: the agents have several types of actions, these are indicated according to an integer value that is sent by the Client. Although we will go into detail in the following posts, the possible values are listed below:\nStatus Query (STATUS) Module loading (LOAD) Module invocation (INVOKE) Module unload (UNLOAD) Module cleaning (CLEAN) Invocation: once it has been decided which action to perform, it is invoked. In this case, the most relevant thing to talk about is the \u0026ldquo;INVOKE\u0026rdquo; action, which is the one used to execute the module sent by the client:\nExecutors available\u003e Executors available # Responsible for the evaluation or execution of the received module are called executors.\nEach executor has its particular way of dealing with the module and, depending on this, the client will have to send it in the appropriate format. Therefore, it is important to choose the right agent to use when deploying it.\nThe executors use the functions of the technology to execute the module code. Currently the list of those that are supported is as follows:\nNote: obviously there are more functionalities that allow you to execute code2 in these three programming languages. But, for this moment, it has been decided to focus the efforts on one of them versatile enough to put the focus on other points of major interest.\nAt the time of invocation, the required arguments are passed directly to the module as indicated. In this case, the default executor of the Standard Agent in Java will be used as an example:\nThe result of the execution is an array of two String elements containing the status code (return code) and the result of the execution (message). With this data, the response can be returned to the Client encapsulating the information in its corresponding place.\nUpon receipt, the Client will determine how to display this response, but this is another story to tell.\nConclusions\u003e Conclusions # At this point, this second part of the series is concluded. Obviously, there are still many questions to be answered and many concepts to be explained.\nIn the next post I will talk about the 2 modes that currently exist in Kraken (ST and C2). I will also explain in depth how is the communication between Client and Agent. Breaking down the message passing structure that is used and showing all the potential it brings.\nI hope you liked the post and see you soon!\nCobaltStrike Beacon Object File (BOF) : https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAlternative code execution methods in Java: https://medium.com/@m01e/jsp-webshell-cookbook-part-1-6836844ceee7\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"17 January 2023","permalink":"/posts/kraken-fundamentals-2/","section":"Posts","summary":"Two fundamental pieces of Kraken\u0026rsquo;s logic are the Modules and Agents. Through these components, you will understand how Kraken performs code execution and takes advantage of its design and architecture to provide the operator with some flexibility and comfort during the post-exploitation phase.","title":"Kraken Fundamentals - II"},{"content":"","date":"17 January 2023","permalink":"/categories/persistence/","section":"Categories","summary":"","title":"Persistence"},{"content":"","date":"17 January 2023","permalink":"/tags/redteam/","section":"Tags","summary":"","title":"redteam"},{"content":"","date":"17 January 2023","permalink":"/authors/secu/","section":"Authors","summary":"","title":"secu"},{"content":"","date":"17 January 2023","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"17 January 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"17 January 2023","permalink":"/tags/webshell/","section":"Tags","summary":"","title":"webshell"},{"content":" We are starting a new year and with it comes new opportunities and new challenges!\nI want to start this 2023 by presenting a project I have been working on for more than a year. And which will be presented at the next Hackplayers Conference (Hc0n) to be celebrated on February 24 and 25 at La Nave (Madrid).\nTo start with the explanation, first I need to \u0026ldquo;seek at the beginning\u0026rdquo;, where it all started and continue from there.\nThis will be the first in a series of posts where I will talk about Kraken, how it works internally and how it can be used.\nSo, grab a snack and\u0026hellip; let\u0026rsquo;s get started!\nIntroduction\u003e Introduction # During one of my Red Team exercises, I was able to compromise many web platforms of client perimeter. The vulnerability I exploited allowed me to deploy a Webshell1 on each of the compromised servers.\nThe reason why we deploy a Webshell instead of using another vector, is to provide as well an execution vector ( TA0002) as a way to maintain access ( TA0003) to the compromised machine.\nAt this point, I was going to start with the reconnaissance, as I was used to do. However, after sharing the findings with my colleagues, I was warned of the possible existence of EDR’s2 in the compromised servers.\nAs these are machines exposed to Internet (Endpoint3), they should have a stronger Hardening4 policy than other computers in the organization.\nIt was at this point that the first problem appeared to me:\nHow can I verify this premise without attracting attention?\n— (because it\u0026rsquo;s it is highly probable that the command execution was monitored)\nIn order to solve this problem, I quickly implemented a proof-of-concept \u0026ldquo;webshell\u0026rdquo; that would allow me to perform basic operations on the system in order to check it.\nAfter using it on one of the compromised servers, I was able to confirm that there was a Linux agent of a well-known EDR which was in operation.\nThis complicated the situation, since it was known in advance that the product would detect any attempt of enumeration using traditional webshell actions.\nAnd there is where the next question was discussed:\nHow I can do a complete reconnaissance without being detected?\nAnd from the answer to this question, a very minimalist version of what Kraken is today was born.\nWhat is Kraken?\u003e What is Kraken? # Kraken is a tool that allows you to manage webshells in multiple programming languages. Maybe we could say that it is something like a \u0026ldquo;webshells orchestrator\u0026rdquo;.\nHowever, the goal that Kraken follows is: to give you the ability to operate as silent as possible. Using, for this purpose, all resources available by the programming language and the operative system.\nHow does Kraken work?\u003e How does Kraken work? # Kraken\u0026rsquo;s execution flow can be simplified in the following diagram:\nOn the one hand, we have the Kraken\u0026rsquo;s Client which is a Python script that can be used to generate webshells and connect to them once they are deployed.\nAnd on the other hand, the Kraken\u0026rsquo;s Agent with which we get to execute the modules that will allow us to obtain the information we are looking for during the reconnaissance procedure.\nLater on we will go deeper into all these components involved in the operation of the tool and why they are there.\nWhat programming languages does Kraken support?\u003e What programming languages does Kraken support? # Currently, Kraken supports:\nPHP (for PHP web services) Java (for JSP) .NET (for ASPX) Obviously this is only a part of all the web technologies currently available, however, I have chosen these three ones because they are the most common and it allows face the problems that appear during the development.\nThose who cover too much, they obtain too little. — Popular Spanish proverb\nOn the other hand, Kraken agents or webshells have been tested on the following operative systems:\nWindows (different versions) Linux (different distributions) Then, a question that arises (or has been there from the beginning) is the following:\nWhat makes it different from other well-known webshells?\u003e What makes it different from other well-known webshells? # Kraken gathers a set of characteristics that have been designed to improve the use of the tool and provide a different view of the use of webshells. Some of the features that make it different from the other tools are:\nExecution of system commands is prevented (its main feature and the purpose for which it was developed). This property makes it very useful on systems where it exists an active monitoring or with the presence of some security solutions which can detect our movements. Its modular design presents some advantages and strengths against other tools:\nIt allows to maintain a multi-version system with which, is determined at runtime, those modules that can be loaded based on the information reported by the agent with whom it communicates. The hierarchy chosen for the module system allows \u0026ldquo;hot-editing\u0026rdquo; of the modules in use. In the same way, it\u0026rsquo;s possible to register modules without stopping program execution. The development of each module seeks to get the maximum exploitation of the language features to get the best recreation of the commands which have been traced. This tends to generate larger modules but with better results. The templates provided for each language make it easy to extend Kraken\u0026rsquo;s functionality and create new modules. Since modules are managed as files, the use of symbolic links (for cases where the implementation does not vary depending on the version) avoids \u0026ldquo;duplicity\u0026rdquo; of the modules. Kraken provides a Cross-Compiling system without added dependencies that allows, for the cases in which it is necessary, to compile the modules without having to worry about having the requirements installed on the machine. This has been achieved thanks to the integration with Docker5.\nThere are currently two modes of using Kraken:\nThe \u0026ldquo;Standard\u0026rdquo; Mode (ST): which is the traditional way webshells work (request-invoking-response style). The \u0026ldquo;Command-and-Control\u0026rdquo; Mode (C2): whose operation is similar to that of a C2 using the load-invocation-unload method of modules using session variables (to be discussed in detail in future posts). Communication flexibility through the use of connection profiles. It is possible to detail all the information about how the communication between client and agent is going to be from a JSON file that follows a specific schema.\nAdditionally, Kraken also provides utilities such as:\nA pseudo-terminal with basic console capabilities. Error control in Agents, Modules and Client. Integrated Logging and History system. And other utilities related to the tool. Conclusions\u003e Conclusions # This brings us to the end of the first part. In the following posts I will go deeper into the internal structure of Kraken, the elements that influence its operation as well as practical examples of use. So don\u0026rsquo;t miss what comes next!\nI hope you have enjoyed it and see you soon!\nWhat is a Webshell? : https://www.imperva.com/learn/application-security/web-shell/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat is an EDR? : https://www.crowdstrike.com/cybersecurity-101/endpoint-security/endpoint-detection-and-response-edr/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat is an Endpoint? : https://www.paloaltonetworks.com/cyberpedia/what-is-an-endpoint\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat is Hardening? : https://www.beyondtrust.com/resources/glossary/systems-hardening\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat is Docker? : https://www.docker.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"9 January 2023","permalink":"/posts/kraken-fundamentals-1/","section":"Posts","summary":"Kraken is a tool for orchestrating webshells developed in PHP, Java and .NET. This is the first post of the Kraken Fundamentals series, where we will talk about how the tool is designed and how it works.","title":"Kraken Fundamentals - I"},{"content":"","date":"9 January 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"My name is Raul Caro Teixido (aka Secu) and I love to develop, research and break all kind of things related with cybersecurity.\nI started in cybersecurity in 2017, when I was in high school and had a lot of time to read and learn. In 2018 I started my first job as a Cybersecurity consultant, and today I have more than 4 years of experience working as a Red Team Analyst (Incide and Blackarrow).\nCurrently, I dedicate my free time to improve/create tools that can be useful in my work, as well as to improve my skills in Red Team. I like to share what I learn because\u0026hellip;\nAre we not the result of what we have learned from others?\nFeel free to contact me at Twitter or LinkedIn.\n","date":"27 December 2022","permalink":"/about/","section":"","summary":"My name is Raul Caro Teixido (aka Secu) and I love to develop, research and break all kind of things related with cybersecurity.\nI started in cybersecurity in 2017, when I was in high school and had a lot of time to read and learn.","title":"About"},{"content":"Since I started in the security world, I have not stopped researching, developing and sharing. Below you will find some of the projects and research to which I have dedicated the most time.\nTools\u003e Tools Logo Title Description Link Kraken A modular multi-language webshell (PHP, JSP, ASPX) focused on web post-exploitation and defense evasion. repository Mistica An open source swiss army knife for arbitrary communication over application protocols. repository Conferences\u003e Conferences Logo Title Type Description Hc0n, 2023 Talk Kraken - A modular multi-language webshell Navaja Negra, 2022 Workshop Design and deploy your own private infrastructure BlackHat Arsenal USA, 2020 Talk Mística: Anything is a tunnel if you're brave enough - Covert channels for everyone! Bitup Alicante, 2020 Talk Covert Channels with Mistica Others\u003e Others Logo Title Description Link LAB.LOCAL A fictitious example of the design and implementation of an organization's Infrastructure. repository CiberReserva Bitup Alicante 2021 CTF Final Challenge, which simulates a Red Team exercise. repository ","date":"27 December 2022","permalink":"/projects/","section":"","summary":"Since I started in the security world, I have not stopped researching, developing and sharing. Below you will find some of the projects and research to which I have dedicated the most time.","title":"Projects"},{"content":"Experience\u003e Experience Company Link Role Dates Location BlackArrow (Tarlogic) Red Team Operator 10/2021 - 12/2022 Madrid, ES INCIDE Digital Data SL Red Team Operator 02/2019 - 10/2021 Barcelona, ES ZATACA SYSTEMS, S.L Cyber Security Consultant 01/2018 - 10/2018 Elche, ES BitUp Alicante Staff Cybersecurity Community 10/2017 - 10/2021 Alicante, ES Certifications\u003e Certifications Logo Company Certification Date Pentester Academy Certified Red Team Expert (CRTE) 03/2022 Offensive Security Offensive Security Certified Proffesional (OSCP) 07/2021 Education\u003e Education School Link Degree Date International University of La Rioja Computer Engineering 2020 - Present University of Alicante Computer Engineering 2016 - 2020 ","date":"27 December 2022","permalink":"/resume/","section":"","summary":"Experience\u003e Experience Company Link Role Dates Location BlackArrow (Tarlogic) Red Team Operator 10/2021 - 12/2022 Madrid, ES INCIDE Digital Data SL Red Team Operator 02/2019 - 10/2021 Barcelona, ES ZATACA SYSTEMS, S.","title":"Resume"}]