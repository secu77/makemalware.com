[{"content":" ","date":"1 March 2023","permalink":"/","section":"","summary":" ","title":""},{"content":"","date":"1 March 2023","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 March 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 March 2023","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"ctf"},{"content":"","date":"1 March 2023","permalink":"/categories/defense-evasion/","section":"Categories","summary":"","title":"Defense Evasion"},{"content":"","date":"1 March 2023","permalink":"/tags/kraken/","section":"Tags","summary":"","title":"kraken"},{"content":"","date":"1 March 2023","permalink":"/tags/redteam/","section":"Tags","summary":"","title":"redteam"},{"content":"","date":"1 March 2023","permalink":"/authors/secu/","section":"Authors","summary":"","title":"secu"},{"content":" Presentation\u003e Presentation # Squid Game is a CTF created for the Hc0n 2023 conference. The scenario has been based on the Netflix series: The Squid Game.\nThe characteristics of this CTF are the following:\nIt consists of three Boot2Root style challenges (get maximum privileges). The web service is used as the Initial Access path. The three machines have been configured to avoid command execution and do not have Internet access. The objective is to perform a post-exploitation through the webshell and achieve privilege escalation. It will not be necessary to perform any additional web exploit, since the challenges are focused on post-exploitation and therefore the initial access is provided. Privilege escalations are fairly straightforward, however, the difficulty lies in the conditions that make exploitation difficult. The following will show the proposed solution for each of the challenges using Kraken, the tool I developed and presented at Hc0n 2023.\nkraken-ng/Kraken Kraken, a modular multi-language webshell coded by @secu_x11 Python 219 16 After this\u0026hellip; Let\u0026rsquo;s get started!\nChallenge 1 - Red Light, Green Light\u003e Challenge 1 - Red Light, Green Light # Name: \u0026ldquo;Red Light, Green Light\u0026rdquo; Operating System: Linux Web Technology: Apache + PHP URL: https://challenge-01.makemalware.com When we visit the link of the first challenge we find the following website:\nIn the robots.txt of the site we can discover a non-indexed endpoint: /upload.php.\nPHP Webshell Deployment\u003e PHP Webshell Deployment # Upon visiting this endpoint, we found what appears to be an arbitrary file upload:\nTo confirm the vulnerability, you can upload an Standard, PHP Kraken agent.\nkraken-ng/agents Agents for https://github.com/kraken-ng/Kraken PHP 6 0 After uploading it, the page returns the remote path where the file has been uploaded. After validating that it is accessible, we proceed to generate a connection profile to connect to the Kraken agent.\nYou can generate connection profiles using a utility that Kraken offers. This is called req2profile and allows you to transform Burpsuite requests to Kraken-compatible Connection Profiles. After defining the JSON fields as shown above, we can connect to the agent:\nSystem reconnaissance\u003e System reconnaissance # With the implant deployed, and the client connected, we can start with the local reconnaissance of the computer.\nFirst of all, we can verify that it is not possible to execute system commands through the webshell itself:\nThis is because, the typical PHP functions for executing commands, have been disabled via the PHP configuration (disabled_functions).\nIt is possible to obtain the list of disabled functions through Kraken using the webinfo module.\nHowever, this configuration does not prevent us from moving through the file system using native functionalities provided by PHP.\nIf we look in the /opt directory, we can find a squid-control folder containing several files and directories of interest.\nAnalyzing the file contents and context information we can identify a Wildcard Poisoning1 vulnerability in the script /opt/squid-control/green-light.sh.\nWildcard Poisoning Exploitation\u003e Wildcard Poisoning Exploitation # Wildcard Poisoning occurs because the script is using a wildcard (*) as an argument to the tar command (indicating that all files in the /var/www/html/files directory should be compressed).\nThis command presents a vulnerability because the wildcard allows the name of a file to be taken as an argument of the tar command itself. And precisely, the tar command contains a number of arguments that may lead to arbitrary code execution2.\nHowever, to confirm the elevation of privileges, we can look at the /opt/squid-control/tmp folder where we can see how, every minute, a file is created with the format: \u0026lt;date\u0026gt;.tar.gz. This contains the files in the /var/www/html/files directory.\nMoreover, the owner of these files is the root user. Therefore, it is possible that there is a cronjob running the /opt/squid-control/green-light.sh script every minute.\nTo confirm this theory, we can use the Kraken module pspy\nThis module lists the Linux processes from the information contained under the file system: /proc. By listing this path, we can discover a series of subdirectories with numerical values. These correspond to the existing PIDs on the machine, and are virtual files containing the information of each process. You can find more information about this file system here.3\nThe module obtains the list of processes in each interval (-i), during the indicated seconds (-d). In this period it detects new processes, processes that stop and displays them in an intuitive format.\nIn this way we can confirm the execution of the /opt/squid-control/green-light.sh script through a cronjob executed as root (otherwise it would not have been possible since the cronjobs of other unprivileged users cannot be listed).\nBefore proceeding with the exploitation, we list the ports in use on the victim machine. For this we can rely on the netstat module which obtains the network information from the virtual files under /proc/net/\nThanks to this module we can identify the existence of a possible SSH service listening on the address 127.0.0.1.1:22.\nWith the information gathered we can set up the following privilege elevation vector:\nA script is uploaded to the machine that, when running, adds an SSH public key to the /root/.ssh/authorized_keys file. This will enable public key based authentication4 as the root user. #!/bin/bash mkdir -p /root/.ssh/ echo -n \u0026#34;ssh-rsa AAAAB3...JMClw==\u0026#34; \u0026gt; /root/.ssh/authorized_keys Next, we create the files that produce the wildcard poisoning exploitation and execute the script from the previous step. SSH access via HTTP Tunneling\u003e SSH access via HTTP Tunneling # After a few seconds, we will proceed to upload a tunneling utility that will allow us to communicate with the internal services of the machine. For this case, I will use pivotnacci.\nblackarrowsec/pivotnacci A tool to make socks connections through HTTP agents Python 588 109 I upload the PHP agent to the /var/www/html/files directory using Kraken\u0026rsquo;s upload module.\nThis module allows you to upload local files in chunks, specifying the delay between requests (-d) as well as the size of each chunk (-c). And, in case the transfer is interrupted/cut off, it can be resumed by specifying the last transmitted seek (-s). This is a good option when uploading large files. With the tunneling utility deployed, we can use the SSH private key to authenticate against the local service of the victim machine and get a console as root.\nFinally, through this console, we have all the privileges and can obtain the challenge flag.\nBefore finishing we delete the files that we have used in the elevation of privileges.\nLD_PRELOAD and alternative flag\u003e LD_PRELOAD and alternative flag # However, the challenge does not end here. There is the possibility of introducing an \u0026ldquo;alternative\u0026rdquo; flag that escapes from the main path of the challenge.\nIn case you have tried to evade the configuration related to the disabled_functions, it is possible that you have tried to do it using some tool like Chankro (which is well known in this kind of post exploits).\nTarlogicSecurity/Chankro Herramienta para evadir disable_functions y open_basedir Python 328 75 However, in the disabled functions are those that allow us to perform the evasion with this tool. Although, if we look at the system variables defined for our user www-data we can discover a predefined value in the variable LD_PRELOAD.\nThis variable points to a library located in /usr/local/lib/falcon.so. Using the download module of Kraken we can download it.\nAt this point, we could reverse engineer and analyze its operation, although it is possible to recover the alternative flag from the strings in the data section of the library.\nEven though I have obtained the flag, I am going to explain the operation and purpose of this library:\nFirstly, it is an adaptation of the code of the zap-args of TheHackersChoice.\nhackerschoice/thc-tips-tricks-hacks-cheat-sheet Various tips \u0026amp; tricks C 2032 265 The zap-args.c code is a defense evasion utility, which focuses on hiding the arguments passed to a command or binary. It uses the LD_PRELOAD variable to intercept the call to main from the execution of your command and empties the reference to the argument array passed to it. So, when doing an ps, the kernel is not able to retrieve the arguments passed to the program, since the reference is empty, and simply displays the binary executed.\nIn my case, I have used the same idea but not to \u0026ldquo;hide\u0026rdquo; the arguments, but to intercept them as an EDR would do. This way you can intercept those commands executed by the www-data user and, in case of calling a shell, block them.\nThe code of falcon.so is as follows:\n/* * gcc -Wall -O2 -fpic -shared -o hook.so hook.c -ldl */ #define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;pwd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; typedef int (*pfi)(int, char **, char **); static pfi real_main; int check_args(int argc, char** argv) { if (argc \u0026lt; 1) return 0; // Checking for shell execution if (strcmp(argv[0], \u0026#34;sh\u0026#34;) == 0) return 1; else if (strcmp(argv[0], \u0026#34;bash\u0026#34;) == 0) return 1; else if (strcmp(argv[0], \u0026#34;rbash\u0026#34;) == 0) return 1; else if (strcmp(argv[0], \u0026#34;dash\u0026#34;) == 0) return 1; return 0; } static int mymain(int argc, char** argv, char** env) { struct passwd *p = getpwuid(getuid()); if (strcmp(p-\u0026gt;pw_name, \u0026#34;www-data\u0026#34;) == 0) { if (check_args(argc, argv) == 1) { char *alt_flag = \u0026#34;squid-game{Byp4ssAllTh3Th1ngS!}\u0026#34;; printf(\u0026#34;Nice try! But it\u0026#39;s not this way. Although, here is your alternative fl4g: %s\u0026#34;, alt_flag); exit(0); } } return real_main(argc, argv, env); } int __libc_start_main(pfi main, int argc, char **ubp_av, void (*init) (void), void (*fini)(void), void (*rtld_fini)(void), void (*stack_end)) { static int (*real___libc_start_main)() = NULL; if (!real___libc_start_main) { char *error; real___libc_start_main = dlsym(RTLD_NEXT, \u0026#34;__libc_start_main\u0026#34;); if ((error = dlerror()) != NULL) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, error); exit(1); } } real_main = main; return real___libc_start_main(mymain, argc, ubp_av, init, fini, rtld_fini, stack_end); } Obviously, it is an insult to expect this to serve as a \u0026ldquo;block\u0026rdquo; against someone who has evaded the proposed defenses. However, it is simply a reward to show the player that he has done well, but that it is not the way.\nSo much for the first challenge.\nChallenge 2 - Dalgona Candy\u003e Challenge 2 - Dalgona Candy # Name: \u0026ldquo;Dalgona Candy\u0026rdquo; Operating System: Windows Web Technology: IIS + ASPX URL: https://challenge-02.makemalware.com Accessing the url of the challenge we can find the following view:\nBy inspecting the page code we discovered a hidden /upload.aspx path:\nASPX Webshell Deployment\u003e ASPX Webshell Deployment # When visiting it we can see, as in the first challenge, an arbitrary file upload.\nIn this case, we proceed to upload a Kraken agent as ASPX.\nWe generate the connection profile specifying the path of the newly deployed agent:\nAnd finally we connect to the webshell using Kraken.\nLocal Reconnaissance\u003e Local Reconnaissance # First, we check that there is an App Locker installed on the machine that prevents us from executing commands with the current Application Pool Identity (WINWS02\\webusr).\nAt this point, we could start doing a exhaustive reconnaissance looking for vulnerable services, programs in use, files with credentials, etc. But in this case, exploitation will be much simpler.\nFirst we check the context of our user, and also his privileges. Using the whoami module is quite easy.\nAs you can see, the SeImpersonate privilege is available, which we can abuse to get SYSTEM.\nPrivilege Elevation with SeImpersonate Privilege\u003e Privilege Elevation with SeImpersonate Privilege # To do this, I am going to use a modified version of the BadPotato program.\nBadPotato uses the Windows print service (spoolss) to exploit a Forced Authentication5. This forced authentication occurs through the RPC call: RpcRemoteFindFirstPrinterChangeNotificationEx(), which generates a notification object that monitors changes to a print object. This is used to force the print service to connect to a NamedPipe that we have created and steal the access token from it. As the user running the print service is the system account, we can use his token to elevate privileges.\nBeichenDream/BadPotato Windows 权限提升 BadPotato C# 599 120 In the modification I remove all the part of the process creation that BadPotato uses to run as SYSTEM.\nOn the other hand, by removing the CloseHandle() from the duplicate token reference, I trigger the leak. This way, the token is leaked in my own process (w3wp.exe) and I can use it later from the webshell context.\nIn addition to getting privilege elevation, I maintain the privileged context from the token reference. What could be considered as a Privilege Elevation + Persistence. Through Kraken\u0026rsquo;s execute_assembly module, I can load the NET Assembly of the modified version of BadPotato and get the leak of the SYSTEM token.\nWith the set_token module, I can use the token reference to make the impersonation of the system account effective. Using an impersonation token derived from the filtering, I can get all the modules that Kraken executes to do so under the SYSTEM security context:\nAfter this, it has been possible to elevate privileges and a \u0026ldquo;pseudo-console\u0026rdquo; is available as the SYSTEM user. So, it is possible to read the desktop flag of the Local Administrator of the machine and complete the challenge.\nSAM, SECURITY and SYSTEM registry extraction\u003e SAM, SECURITY and SYSTEM registry extraction # However, in a more realistic scenario, proving privileges would not be enough. It would be necessary to perform some kind of post-exploitation to compromise the machine and/or obtain credentials.\nTo demonstrate the possibility of performing this task with Kraken, we will use the secretsdump module that will allow us to extract the SAM, SECURITY and SYSTEM from the machine registry.\nThe secretsdump module combines impersonation with the use of Transacted Files to achieve that, the call to NtSaveKey() saves the content of the registry key in an \u0026ldquo;in memory\u0026rdquo; file. In this way we can access its content, but it is not written to disk, so we can exfiltrate it without the need to complete the transaction. At the moment the module writes the files to our local machine, we can use the utility: secretsdump of Impacket to obtain the local accounts of the machine.\nfortra/impacket Impacket is a collection of Python classes for working with network protocols. Python 10710 3049 With the information obtained in this process, it is possible to use it to get an interactive session on the compromised machine (independent of the webshell).\nAnd with this, the second challenge is completed.\nChallenge 3 - The Glass Tile\u003e Challenge 3 - The Glass Tile # Name: \u0026ldquo;The Glass Tile\u0026rdquo; Operating System: Windows Web Technology: IIS + ASPX URL: https://challenge-03.makemalware.com This challenge is intended to demonstrate the potential of using Windows tokens during the web post-exploitation process. The idea came from research done by my colleague Kurosh Dabag Escalante: One shell to HANDLE them all.6\nSo, let\u0026rsquo;s start by visiting the url of the challenge:\nAgain we can see in the source code some hidden paths:\nWhen visiting the /admin endpoint we find a simple static page. There doesn\u0026rsquo;t seem to be much more to it.\nASPX Webshell Deployment\u003e ASPX Webshell Deployment # On the other hand, if we visit the /upload.aspx path we again encounter an arbitrary file upload.\nSo we are back to uploading a Kraken ASPX agent as in the previous challenge.\nWe generate a connection profile and, again, connect to the agent.\nLocal reconnaissance and token leakage\u003e Local reconnaissance and token leakage # We advise the same policies of the App Locker that prevent the execution of commands:\nHowever, when listing the existing tokens in our process, we discovered one under the security context of the user WINWS03\\square.\nWhen impersonating this user we can verify that it is a member of the local Administrators group of the machine, and that the token is in high integrity.\nThe explanation to this is that, there is a Virtual Directory configured in the IIS. This virtual directory points to the local path: C:/Users/square/adminsite/. In order for the Application Pool Identity to access this directory, it needs a pair of valid credentials. For this case, ones have been configured in ClearText of the user WINWS03\\square.\nThe endpoint that manages this virtual directory is /admin, therefore, when accessing this endpoint, the IIS authenticates as the WINWS03\\square user to access, which results in the leak of a primary token as this user.\nElevation of Privileges with nested impersonations\u003e Elevation of Privileges with nested impersonations # Through the first impersonation we managed to elevate privileges from WINWS03\\webusr to WINWS03\\square (local admin). However, to get the highest number of privileges on the computer, it is necessary to escalate to SYSTEM.\nTo do this, as we have administrator privileges and are in high integrity, we proceed to search for a process running as SYSTEM. To do this we use the ps module of Kraken and, among the different processes, we identify a candidate: winlogon.exe.\nIt is well known that the winlogon process runs on the system account and, in addition to this, it is possible to duplicate its main token and use it for impersonation. Using Kraken\u0026rsquo;s dup_token module, we can duplicate the winlogon token and get one as SYSTEM in our current process.\nWhen using this token and impersonating the system account, we go to the directory C:/Users/Administrator/Desktop where the flag is located. And, if we try to read the flag, we get a \u0026ldquo;permission denied\u0026rdquo; error.\nThis is because there is an ACL configured in the squid-flag.txt file so that it can only be accessed by its owner: WINWS03\\Administrator.\nIn order to set this ACL and remove the rest, the \u0026quot; inherited permissions \u0026ldquo; had to be removed from the file. Given this configuration, the possibility of impersonating the WINWS03\\Administrator user is suggested. In order to do this, we check the list of processes again, and find a promising one:\nThe process with PID: 3132, corresponds to a Procmon64, which is running under the directory C:/Users/Administrator/Downloads/ProcessMonitor, which means that it is possible that this user has launched the process in his logon session.\nThe premise is confirmed through the duplication of the process token, and the impersonation by making use of it. In this context, the challenge flag can finally be accessed:\nExtraction of secrets through the IIS Administration Module\u003e Extraction of secrets through the IIS Administration Module # And finally, to complete the post-exploitation, having Administrator and High Integrity privileges, it is possible to extract the secrets configured in the IIS using the library: Microsoft.Web.Administration (used for the administration of the web server).\nThrough this functionality, it is possible to retrieve the plaintext credentials configured for any AppPool, VirtualDirectory or AppPoolIdentity. To do this, just use the Kraken module dump_iis_secrets\nTo develop the dump_iis_secrets module, I used the idea described by Grzegorz Tworek in one of his Tweets7 that talks about the possibility of extracting these credentials using the appcmd.exe binary.\nConclusions\u003e Conclusions # In conclusion, the potential and comfort in using Kraken as a web post-exploitation tool is demonstrated. Different exploits in different scenarios have been covered.\nFinally, you can find the code of the challenges, as well as the commands used, at the following link.\nOr, you can download the OVAs of the challenges from Mega.\nHope you liked it, and see you in the next post!\nBack To The Future: Unix Wildcards Gone Wild : https://www.exploit-db.com/papers/33930\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nArbitrary code execution using /usr/bin/tar : https://gtfobins.github.io/gtfobins/tar/#shell\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe file system /proc : https://tldp.org/pub/Linux/docs/ldp-archived/system-admin-guide/translations/es/html/ch04s07.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSSH Public Key Authentication : https://www.ssh.com/academy/ssh/public-key-authentication\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nForced Authentication : https://www.ired.team/offensive-security/initial-access/t1187-forced-authentication\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOne shell to HANDLE them all : https://www.tarlogic.com/es/blog/abuso-handles-token/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n0gtweet IIS Application Pool credential dumping : https://twitter.com/0gtweet/status/1588815661085917186\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 March 2023","permalink":"/posts/squid-game-ctf/","section":"Posts","summary":"Squid Game is a CTF created for the congress: Hc0n 2023. It consists of three Boot2root style challenges through an initial web access. The objective of the challenges is: to perform a post-exploitation via webshell on restricted environments and to gain privileges. In this post, we will show the proposed solutions for these challenges.","title":"Squid Game CTF - Hc0n 2023"},{"content":"","date":"1 March 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"1 March 2023","permalink":"/tags/webshell/","section":"Tags","summary":"","title":"webshell"},{"content":"","date":"17 January 2023","permalink":"/series/kraken-fundamentals/","section":"Series","summary":"","title":"Kraken Fundamentals"},{"content":" In the first part of this series: \u0026ldquo;Kraken Fundamentals\u0026rdquo;, I talked about what Kraken is and how it works at a high level.\nAfter this introduction, in this second part, I will present in detail and in depth, two fundamental components in Kraken: Modules and Agents.\nThe objective is to explain their design, structure, operation and how they relate to each other.\nAlthough this post will be a little longer and more detailed than the previous one, I hope that it will be possible to understand how Kraken operates and the possibility of scaling it to any need.\nAnd after this\u0026hellip; Let\u0026rsquo;s get started!\nKraken modules\u003e Kraken modules # The first question to answer when approaching this section is the following:\nWhat is a module?\u003e What is a module? # Kraken modules are those pieces of code that allow you to perform one or more actions on the operating system on which it runs.\nGenerally, a module is a class, in the corresponding programming language, that contains all the logic to fulfill the purpose for which it has been developed. For this, it uses all the resources available in the language libraries and/or in the system in which it is located.\nTypes of modules\u003e Types of modules # Although, it is practically irrelevant, but theoretically there are two types of modules in Kraken: native and abstract modules.\nNative Modules are (native) re-implementations of operating system commands. They allow to obtain information similar to that displayed by a system command, that is being imitated, when executed.\nThese modules can be very useful in the first reconnaissance phase. At that time, the possible existence of security solutions or other defensive products is unknown. In this way, an alternative is presented to avoid detection as soon as post-exploitation begins.\nHowever, the accuracy with which the functionality of a system command can be recreated depends entirely on the programming language used and the context. In some technologies, there may be a lack of functionality due to the inability to perform certain actions. On the other hand, Abstract Modules do not correspond to system commands, but perform a more complex action that is abstracted from the operating system. An example of an abstract command could be: the action to upload and download files, or for example, a module to perform a local or remote port scan.\nHierarchy of the modules\u003e Hierarchy of the modules # An important detail to know about the modules is: \u0026ldquo;how they are organized\u0026rdquo;. Because their arrangement allows Kraken to select the modules it needs when it needs them.\nTo explain the hierarchy, we have to go to the modules/ folder in the root of the project. This directory looks like this:\n. └── modules ├── modules.py # module configuration ├── template.php # example templates ├── template.java ├── template.cs └── cd # module directory ├── cd.cs4.cs # implementation in .NET 4 ├── cd.java1.7.java # implementation in Java 7 ├── cd.java1.8.java ├── cd.php5.php # implementation in PHP 5 ├── cd.php7.php └── cd.php8.php On the one hand, we have the templates: which are model files for the creation of modules in their respective languages. We can also find the modules.py file which contains the definition and configuration of all Kraken modules (I will explain this later).\nAnd on the other hand, we have different directories that correspond to the modules available in Kraken.\nAs you can see, inside each of these directories, you can find the different versions of each module developed in the supported programming languages. The naming convention is as follows:\nThis format is important because:\nIt allows the separation between the programming languages used (because there are modules that are only available in certain languages). It facilitates the versioning of the modules that allows to keep different implementations depending on the version of the programming language or technology (this is useful for backward compatibility, because if we use relatively new language functions, our modules will not work in previous versions). For those modules whose implementation does not differ in different versions, the same content is maintained but using a symbolic link to avoid duplicate files. With this information, Kraken, at runtime, knows what type of agent it is communicating with, and is able to offer the operator those modules that can be executed in the context in which it is.\nAn example of this is: if you do not have the module \u0026ldquo;ls\u0026rdquo; for PHP version 5.4, Kraken will not show it in the tty. On the other hand, if you have a module for all PHP 5 subversions, then Kraken will allow you to use it.\nModule structure\u003e Module structure # The structure of Kraken modules may vary slightly between programming languages (as each has its own loading methods and this affects their implementation), however, the modules have been designed to follow a common idea.\nTo show this pattern between modules, the current Java template will be used as an example:\nimport java.io.*; import java.util.*; import java.text.*; import javax.xml.bind.*; import java.util.regex.*; public class Module_template { private final String SUCC_CODE = \u0026#34;0\u0026#34;; private final String ERR_CODE = \u0026#34;1\u0026#34;; private final String JAVA_EOL = System.lineSeparator(); private String hex2str(String data) { byte[] data_bytes = DatatypeConverter.parseHexBinary(data); String data_string = new String(data_bytes); return data_string; } private String normalizePath(String currPath) { currPath = currPath.replace(\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); currPath = currPath.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#34;); currPath = currPath.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;); return currPath; } private String[] parseArgs(String args) { String regex = \u0026#34;\\\u0026#34;[^\\\u0026#34;]+\\\u0026#34;|\u0026#39;[^\u0026#39;]+\u0026#39;|\\\\S+\u0026#34;; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(args); List\u0026lt;String\u0026gt; arguments = new ArrayList\u0026lt;String\u0026gt;(); while (matcher.find()) arguments.add(matcher.group(0)); String[] arguments_arr = new String[arguments.size()]; arguments_arr = arguments.toArray(arguments_arr); return arguments_arr; } private String changeCWD(String cwd) throws Exception { File target_dir = new File(cwd).getAbsoluteFile(); if (target_dir.exists() == false) throw new Exception(\u0026#34;Directory: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: does not exist\u0026#34;); if (target_dir.canRead() == false) throw new Exception(\u0026#34;Can\u0026#39;t move to path: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: permission denied\u0026#34;); if (target_dir.isDirectory() == false) throw new Exception(\u0026#34;Path: \u0026#39;\u0026#34; + cwd + \u0026#34;\u0026#39;: is not a directory\u0026#34;); System.setProperty(\u0026#34;user.dir\u0026#34;, target_dir.getCanonicalPath()); return normalizePath(target_dir.getCanonicalPath()); } private String[] doAction(String param_one, String param_two, String param_three) { String output = \u0026#34;\u0026#34;; try { output = \u0026#34;do something\u0026#34; + JAVA_EOL; } catch(Exception ex) { return new String[]{ERR_CODE, ex.ToString() + JAVA_EOL}; } return new String[]{SUCC_CODE, output}; } public String[] execute(String[] args) { if (args.length != 1) return new String[]{ERR_CODE, \u0026#34;Invalid arguments provided. Only one directory is allowed to be moved\u0026#34; + JAVA_EOL}; return doAction(args[0]); } public String[] go(String module_cwd, String module_args) { try { String new_cwd = changeCWD(hex2str(module_cwd)); String[] args = parseArgs(hex2str(module_args)); return execute(args); } catch(Exception ex) { return new String[]{ERR_CODE, ex.getMessage() + JAVA_EOL}; } } public static void main(String[] args) { Module_template m = new Module_template(); String[] results = m.execute(args); System.out.println(results[1]); return; } } After examining the template code, some aspects of interest will be highlighted:\nThe module consists of a Class, which is instantiated and invoked (the way will depend on the executor used in each technology) but all of them follow this line. In this class we can see a \u0026ldquo;main\u0026rdquo; method which is important because, the module must be able to be compiled locally and executed. In this way, you can maintain a common structure that allows the same modules that Kraken invokes, to be easily compiled and executed locally (obviously with its pertinent modifications). The modules must have a public method: go() that allows passing the necessary arguments from the agent to the module. The flow of this function is the following: With hex2str(), we obtain the values of the arguments that are passed in hexadecimal format to the module. With changeCWD() the \u0026ldquo;Current Working Directory\u0026rdquo; (cwd) of the module is set. The change between directories has to be maintained in the client and send the reference to the agent. Then, the arguments are processed with parseArgs(), which returns them in an array ready to be used by the module. Finally, the execute() method is called, which will process the arguments and invoke the function that performs the target action. The concept of this go() function is similar to how it is used in Cobaltstrike BOF\u0026rsquo;s1.\nIt is important to note that, in the case of PHP, the go() function is suppressed because the default PHP executor evaluates the module code as is. This makes it unnecessary to instantiate the class and call the method (as we would do in Java or .NET) but to execute the code directly. After this, the do...() function is called, which will be used to perform the actions for which the module has been developed. This method will return an array with two elements: The return code (status_code): the one that indicates whether the execution has been successful or not. The result as the content of the message to be displayed (message). Finally, both the functions previous to the doAction() of this example, as well as the attributes of the class, will be essential elements for the modules to work. Therefore, it is important to use the available templates so that the modules follow the same format. In future posts I will talk about the creation of modules (and other Kraken elements) and how to use them.\nModule configuration\u003e Module configuration # Now, Kraken modules are not just code files, they must also provide some characteristics to be used, for example:\nWhat arguments do you need, and what type? For which technologies is it available? Can it be used on any operating system? How should the module work? Should it interact with any element of the client? How should the result of the execution be displayed? These and more questions are answered in the file: modules/modules.py mentioned above.\nUsing this Python language structure, Kraken is able to understand how it should handle each existing module. To show each of the fields, the configuration related to the ls module will be used as an example:\n{ \u0026#34;name\u0026#34; : \u0026#34;ls\u0026#34;, \u0026#34;template\u0026#34; : \u0026#34;ls\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;List files or directories\u0026#34;, \u0026#34;author\u0026#34; : \u0026#34;@secu_x11\u0026#34;, \u0026#34;examples\u0026#34; : [ \u0026#34;ls\u0026#34;, \u0026#34;ls ..\u0026#34;, \u0026#34;ls /etc\u0026#34;, \u0026#34;ls -R /etc\u0026#34;, \u0026#34;ls C:/Users\u0026#34; ], \u0026#34;so\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;Linux\u0026#34;, \u0026#34;agents\u0026#34; : [\u0026#34;php\u0026#34;,\u0026#34;java\u0026#34;] }, { \u0026#34;name\u0026#34; : \u0026#34;Windows\u0026#34;, \u0026#34;agents\u0026#34; : [\u0026#34;php\u0026#34;,\u0026#34;java\u0026#34;,\u0026#34;cs\u0026#34;] } ], \u0026#34;args\u0026#34; : [ { \u0026#34;-R\u0026#34;: { \u0026#34;help\u0026#34;: \u0026#34;Recursive mode\u0026#34;, \u0026#34;action\u0026#34; : \u0026#34;store_true\u0026#34;, \u0026#34;required\u0026#34;: 0 }, \u0026#34;files\u0026#34;: { \u0026#34;help\u0026#34;: \u0026#34;Files to list\u0026#34;, \u0026#34;nargs\u0026#34; : \u0026#34;*\u0026#34;, \u0026#34;type\u0026#34;: str } } ], \u0026#34;dispatcher\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;formater\u0026#34; : \u0026#34;columns\u0026#34; } Here are some of the fields that may cause questions:\nTemplate: corresponds to the name of the template to be used in the file hierarchy of the modules/ directory (this usually/must match the name of the module in question). Operating System: here is the information about the operating systems and technologies for which the module is supported. Arguments: the only thing to note about this field is that the arguments are defined with the structure used by argparser. In this way, the validation of the arguments can be delegated to this library. Dispatcher: here is the name of the component that will be responsible for defining how the module is processed by the Kraken Client (this will be discussed later). Formater: as with the dispatcher, the formater is a component that defines how the results returned by the agent should be displayed. Other considerations\u003e Other considerations # Another important detail is that, thanks to this hierarchy, the operator can \u0026ldquo;hot edit\u0026rdquo; the modules.\nFor example, it can happen that a post-exploitation module is developed for Kraken, and\u0026hellip; when executed, it does not return the expected information or fails directly. In that case, it is possible to edit the content of the module on disk and re-execute it (in PHP and .NET) or recompile it (in Java).\nIn this way, a certain flexibility is provided to the operator who can adjust his intrusion to the environment in which he finds himself.\nKraken agents\u003e Kraken agents # In order for the modules to be executed and the response obtained, they must be received and processed by the other fundamental component in Kraken: the Agents.\nWhat is an Agent?\u003e What is an Agent? # A Kraken Agent is a file that is located in an accessible directory of the web service and allows the loading of Kraken modules. To do this, it receives, processes and interprets the content of the modules and arguments necessary for its proper execution.\nTypes of Agents\u003e Types of Agents # Currently, agents can be found under the agents/ directory. There are 2 types of agents:\nStandard Agents: to use with st mode. Command-and-Control agents: for use with c2 mode. Under the subdirectory c2/ there is only one agent, since at this moment I have only had time to make the implementation in PHP. This mode is \u0026ldquo;experimental\u0026rdquo; and has not yet been fully tested. Nevertheless it is usable and works correctly.\nOn the other hand, in the subdirectory st/ we can find 3 versions of agents that correspond to the available technologies: PHP, Java and .NET.\nIn future versions of Kraken, we will add the possibility of using a webshell generator that allows you to select between different types of webshells depending on the environment and features you want. For now, the available webshells/agents are static and some fields inside them must be modified to customize their use. General structure\u003e General structure # The structure of the Agent varies according to its type. Although, like the modules, they follow the same pattern. The following diagram shows, in a simplified way, the flow of a Kraken Agent:\ngraph TD; A[Agent] --\u003e|Receives HTTP request| B{Authentication} B --\u003e |Wrong| C(Return Response) B --\u003e |Right| D[Handle] D --\u003e E{Parameter \\nextraction} E --\u003e |Invalid| C E --\u003e |Valid| F{Check \\nCode Action} F --\u003e |Nonexistent| C F --\u003e |Existent| G[Invoke Action] G --\u003e H[Extraction of \\nthe Response] H --\u003e C The agents perform a rigorous check of the parameters encapsulated in the HTTP request. Based on these parameters, actions are performed according to the values contained in them.\nSome of the most important elements in the agent are:\nAuthentication: the first step for the communication between Client and Kraken Agent to be successful, consists of an authentication process with symmetric key: The key must be known by the Agent and by the Client (this will be discussed in depth in the next post). The same authentication key is used to encrypt the content of the modules and arguments. The encryption and decryption process is a simple XOR operation on the value of the chosen key at both ends. Parameter Extraction: module and the required arguments are encapsulated in the HTTP request by the Client. As it encapsulates them, the Agent must know where they are embedded because it has to perform the reverse process to obtain them. This information is related to the Connection Profiles that will be explained later: Action Codes: the agents have several types of actions, these are indicated according to an integer value that is sent by the Client. Although we will go into detail in the following posts, the possible values are listed below:\nStatus Query (STATUS) Module loading (LOAD) Module invocation (INVOKE) Module unload (UNLOAD) Module cleaning (CLEAN) Invocation: once it has been decided which action to perform, it is invoked. In this case, the most relevant thing to talk about is the \u0026ldquo;INVOKE\u0026rdquo; action, which is the one used to execute the module sent by the client:\nExecutors available\u003e Executors available # Responsible for the evaluation or execution of the received module are called executors.\nEach executor has its particular way of dealing with the module and, depending on this, the client will have to send it in the appropriate format. Therefore, it is important to choose the right agent to use when deploying it.\nThe executors use the functions of the technology to execute the module code. Currently the list of those that are supported is as follows:\nNote: obviously there are more functionalities that allow you to execute code2 in these three programming languages. But, for this moment, it has been decided to focus the efforts on one of them versatile enough to put the focus on other points of major interest.\nAt the time of invocation, the required arguments are passed directly to the module as indicated. In this case, the default executor of the Standard Agent in Java will be used as an example:\nThe result of the execution is an array of two String elements containing the status code (return code) and the result of the execution (message). With this data, the response can be returned to the Client encapsulating the information in its corresponding place.\nUpon receipt, the Client will determine how to display this response, but this is another story to tell.\nConclusions\u003e Conclusions # At this point, this second part of the series is concluded. Obviously, there are still many questions to be answered and many concepts to be explained.\nIn the next post I will talk about the 2 modes that currently exist in Kraken (ST and C2). I will also explain in depth how is the communication between Client and Agent. Breaking down the message passing structure that is used and showing all the potential it brings.\nI hope you liked the post and see you soon!\nCobaltStrike Beacon Object File (BOF) : https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAlternative code execution methods in Java: https://medium.com/@m01e/jsp-webshell-cookbook-part-1-6836844ceee7\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"17 January 2023","permalink":"/posts/kraken-fundamentals-2/","section":"Posts","summary":"Two fundamental pieces of Kraken\u0026rsquo;s logic are the Modules and Agents. Through these components, you will understand how Kraken performs code execution and takes advantage of its design and architecture to provide the operator with some flexibility and comfort during the post-exploitation phase.","title":"Kraken Fundamentals - II"},{"content":"","date":"17 January 2023","permalink":"/categories/persistence/","section":"Categories","summary":"","title":"Persistence"},{"content":"","date":"17 January 2023","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":" We are starting a new year and with it comes new opportunities and new challenges!\nI want to start this 2023 by presenting a project I have been working on for more than a year. And which will be presented at the next Hackplayers Conference (Hc0n) to be celebrated on February 24 and 25 at La Nave (Madrid).\nTo start with the explanation, first I need to \u0026ldquo;seek at the beginning\u0026rdquo;, where it all started and continue from there.\nThis will be the first in a series of posts where I will talk about Kraken, how it works internally and how it can be used.\nSo, grab a snack and\u0026hellip; let\u0026rsquo;s get started!\nIntroduction\u003e Introduction # During one of my Red Team exercises, I was able to compromise many web platforms of client perimeter. The vulnerability I exploited allowed me to deploy a Webshell1 on each of the compromised servers.\nThe reason why we deploy a Webshell instead of using another vector, is to provide as well an execution vector ( TA0002) as a way to maintain access ( TA0003) to the compromised machine.\nAt this point, I was going to start with the reconnaissance, as I was used to do. However, after sharing the findings with my colleagues, I was warned of the possible existence of EDR’s2 in the compromised servers.\nAs these are machines exposed to Internet (Endpoint3), they should have a stronger Hardening4 policy than other computers in the organization.\nIt was at this point that the first problem appeared to me:\nHow can I verify this premise without attracting attention?\n— (because it\u0026rsquo;s it is highly probable that the command execution was monitored)\nIn order to solve this problem, I quickly implemented a proof-of-concept \u0026ldquo;webshell\u0026rdquo; that would allow me to perform basic operations on the system in order to check it.\nAfter using it on one of the compromised servers, I was able to confirm that there was a Linux agent of a well-known EDR which was in operation.\nThis complicated the situation, since it was known in advance that the product would detect any attempt of enumeration using traditional webshell actions.\nAnd there is where the next question was discussed:\nHow I can do a complete reconnaissance without being detected?\nAnd from the answer to this question, a very minimalist version of what Kraken is today was born.\nWhat is Kraken?\u003e What is Kraken? # Kraken is a tool that allows you to manage webshells in multiple programming languages. Maybe we could say that it is something like a \u0026ldquo;webshells orchestrator\u0026rdquo;.\nHowever, the goal that Kraken follows is: to give you the ability to operate as silent as possible. Using, for this purpose, all resources available by the programming language and the operative system.\nHow does Kraken work?\u003e How does Kraken work? # Kraken\u0026rsquo;s execution flow can be simplified in the following diagram:\nOn the one hand, we have the Kraken\u0026rsquo;s Client which is a Python script that can be used to generate webshells and connect to them once they are deployed.\nAnd on the other hand, the Kraken\u0026rsquo;s Agent with which we get to execute the modules that will allow us to obtain the information we are looking for during the reconnaissance procedure.\nLater on we will go deeper into all these components involved in the operation of the tool and why they are there.\nWhat programming languages does Kraken support?\u003e What programming languages does Kraken support? # Currently, Kraken supports:\nPHP (for PHP web services) Java (for JSP) .NET (for ASPX) Obviously this is only a part of all the web technologies currently available, however, I have chosen these three ones because they are the most common and it allows face the problems that appear during the development.\nThose who cover too much, they obtain too little. — Popular Spanish proverb\nOn the other hand, Kraken agents or webshells have been tested on the following operative systems:\nWindows (different versions) Linux (different distributions) Then, a question that arises (or has been there from the beginning) is the following:\nWhat makes it different from other well-known webshells?\u003e What makes it different from other well-known webshells? # Kraken gathers a set of characteristics that have been designed to improve the use of the tool and provide a different view of the use of webshells. Some of the features that make it different from the other tools are:\nExecution of system commands is prevented (its main feature and the purpose for which it was developed). This property makes it very useful on systems where it exists an active monitoring or with the presence of some security solutions which can detect our movements. Its modular design presents some advantages and strengths against other tools:\nIt allows to maintain a multi-version system with which, is determined at runtime, those modules that can be loaded based on the information reported by the agent with whom it communicates. The hierarchy chosen for the module system allows \u0026ldquo;hot-editing\u0026rdquo; of the modules in use. In the same way, it\u0026rsquo;s possible to register modules without stopping program execution. The development of each module seeks to get the maximum exploitation of the language features to get the best recreation of the commands which have been traced. This tends to generate larger modules but with better results. The templates provided for each language make it easy to extend Kraken\u0026rsquo;s functionality and create new modules. Since modules are managed as files, the use of symbolic links (for cases where the implementation does not vary depending on the version) avoids \u0026ldquo;duplicity\u0026rdquo; of the modules. Kraken provides a Cross-Compiling system without added dependencies that allows, for the cases in which it is necessary, to compile the modules without having to worry about having the requirements installed on the machine. This has been achieved thanks to the integration with Docker5.\nThere are currently two modes of using Kraken:\nThe \u0026ldquo;Standard\u0026rdquo; Mode (ST): which is the traditional way webshells work (request-invoking-response style). The \u0026ldquo;Command-and-Control\u0026rdquo; Mode (C2): whose operation is similar to that of a C2 using the load-invocation-unload method of modules using session variables (to be discussed in detail in future posts). Communication flexibility through the use of connection profiles. It is possible to detail all the information about how the communication between client and agent is going to be from a JSON file that follows a specific schema.\nAdditionally, Kraken also provides utilities such as:\nA pseudo-terminal with basic console capabilities. Error control in Agents, Modules and Client. Integrated Logging and History system. And other utilities related to the tool. Conclusions\u003e Conclusions # This brings us to the end of the first part. In the following posts I will go deeper into the internal structure of Kraken, the elements that influence its operation as well as practical examples of use. So don\u0026rsquo;t miss what comes next!\nI hope you have enjoyed it and see you soon!\nWhat is a Webshell? : https://www.imperva.com/learn/application-security/web-shell/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat is an EDR? : https://www.crowdstrike.com/cybersecurity-101/endpoint-security/endpoint-detection-and-response-edr/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat is an Endpoint? : https://www.paloaltonetworks.com/cyberpedia/what-is-an-endpoint\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat is Hardening? : https://www.beyondtrust.com/resources/glossary/systems-hardening\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat is Docker? : https://www.docker.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"9 January 2023","permalink":"/posts/kraken-fundamentals-1/","section":"Posts","summary":"Kraken is a tool for orchestrating webshells developed in PHP, Java and .NET. This is the first post of the Kraken Fundamentals series, where we will talk about how the tool is designed and how it works.","title":"Kraken Fundamentals - I"},{"content":"","date":"9 January 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"My name is Raul Caro Teixido (aka Secu) and I love to develop, research and break all kind of things related with cybersecurity.\nI started in cybersecurity in 2017, when I was in high school and had a lot of time to read and learn. In 2018 I started my first job as a Cybersecurity consultant, and today I have more than 4 years of experience working as a Red Team Analyst (Incide and Blackarrow).\nCurrently, I dedicate my free time to improve/create tools that can be useful in my work, as well as to improve my skills in Red Team. I like to share what I learn because\u0026hellip;\nAre we not the result of what we have learned from others?\nFeel free to contact me at Twitter or LinkedIn.\n","date":"27 December 2022","permalink":"/about/","section":"","summary":"My name is Raul Caro Teixido (aka Secu) and I love to develop, research and break all kind of things related with cybersecurity.\nI started in cybersecurity in 2017, when I was in high school and had a lot of time to read and learn.","title":"About"},{"content":"Since I started in the security world, I have not stopped researching, developing and sharing. Below you will find some of the projects and research to which I have dedicated the most time.\nTools\u003e Tools Logo Title Description Link Kraken A modular multi-language webshell (PHP, JSP, ASPX) focused on web post-exploitation and defense evasion. repository Mistica An open source swiss army knife for arbitrary communication over application protocols. repository Conferences\u003e Conferences Logo Title Type Description Hc0n, 2023 Talk Kraken - A modular multi-language webshell Navaja Negra, 2022 Workshop Design and deploy your own private infrastructure BlackHat Arsenal USA, 2020 Talk Mística: Anything is a tunnel if you're brave enough - Covert channels for everyone! Bitup Alicante, 2020 Talk Covert Channels with Mistica Others\u003e Others Logo Title Description Link LAB.LOCAL A fictitious example of the design and implementation of an organization's Infrastructure. repository CiberReserva Bitup Alicante 2021 CTF Final Challenge, which simulates a Red Team exercise. repository ","date":"27 December 2022","permalink":"/projects/","section":"","summary":"Since I started in the security world, I have not stopped researching, developing and sharing. Below you will find some of the projects and research to which I have dedicated the most time.","title":"Projects"},{"content":"Experience\u003e Experience Company Link Role Dates Location BlackArrow (Tarlogic) Red Team Operator 10/2021 - 12/2022 Madrid, ES INCIDE Digital Data SL Red Team Operator 02/2019 - 10/2021 Barcelona, ES ZATACA SYSTEMS, S.L Cyber Security Consultant 01/2018 - 10/2018 Elche, ES BitUp Alicante Staff Cybersecurity Community 10/2017 - 10/2021 Alicante, ES Certifications\u003e Certifications Logo Company Certification Date Pentester Academy Certified Red Team Expert (CRTE) 03/2022 Offensive Security Offensive Security Certified Proffesional (OSCP) 07/2021 Education\u003e Education School Link Degree Date International University of La Rioja Computer Engineering 2020 - Present University of Alicante Computer Engineering 2016 - 2020 ","date":"27 December 2022","permalink":"/resume/","section":"","summary":"Experience\u003e Experience Company Link Role Dates Location BlackArrow (Tarlogic) Red Team Operator 10/2021 - 12/2022 Madrid, ES INCIDE Digital Data SL Red Team Operator 02/2019 - 10/2021 Barcelona, ES ZATACA SYSTEMS, S.","title":"Resume"}]